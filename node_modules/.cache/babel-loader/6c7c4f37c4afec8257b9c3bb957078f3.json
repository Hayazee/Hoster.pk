{"ast":null,"code":"// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\nvar assert = require('assert');\n\nvar ASN1 = require('./types');\n\nvar errors = require('./errors'); ///--- Globals\n\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error; ///--- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data)) throw new TypeError('data must be a node Buffer');\n  this._buf = data;\n  this._size = data.length; // These hold the \"current\" state\n\n  this._len = 0;\n  this._offset = 0;\n  var self = this;\n\n  this.__defineGetter__('length', function () {\n    return self._len;\n  });\n\n  this.__defineGetter__('offset', function () {\n    return self._offset;\n  });\n\n  this.__defineGetter__('remain', function () {\n    return self._size - self._offset;\n  });\n\n  this.__defineGetter__('buffer', function () {\n    return self._buf.slice(self._offset);\n  });\n}\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\n\n\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1) return null;\n  var b = this._buf[this._offset] & 0xff;\n  if (!peek) this._offset += 1;\n  return b;\n};\n\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\n\n\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined) offset = this._offset;\n  if (offset >= this._size) return null;\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null) return null;\n\n  if ((lenB & 0x80) == 0x80) {\n    lenB &= 0x7f;\n    if (lenB == 0) throw newInvalidAsn1Error('Indefinite length not supported');\n    if (lenB > 4) throw newInvalidAsn1Error('encoding too long');\n    if (this._size - offset < lenB) return null;\n    this._len = 0;\n\n    for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\n\n\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null) return null;\n  if (tag !== undefined && tag !== seq) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + seq.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  this._offset = o;\n  return seq;\n};\n\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\n\nReader.prototype.readBoolean = function () {\n  return this._readTag(ASN1.Boolean) === 0 ? false : true;\n};\n\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\n\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag) tag = ASN1.OctetString;\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  if (this.length === 0) return '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n\n  this._offset += this.length;\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function (tag) {\n  if (!tag) tag = ASN1.OID;\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    var byte = this._buf[this._offset++] & 0xff;\n    value <<= 7;\n    value += byte & 0x7f;\n\n    if ((byte & 0x80) == 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift(value / 40 >> 0);\n  return values.join('.');\n};\n\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n  var b = this.peek();\n  if (b === null) return null;\n  if (b !== tag) throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) + ': got 0x' + b.toString(16));\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null) return null;\n  if (this.length > 4) throw newInvalidAsn1Error('Integer too long: ' + this.length);\n  if (this.length > this._size - o) return null;\n  this._offset = o;\n  var fb = this._buf[this._offset++];\n  var value = 0;\n  value = fb & 0x7F;\n\n  for (var i = 1; i < this.length; i++) {\n    value <<= 8;\n    value |= this._buf[this._offset++] & 0xff;\n  }\n\n  if ((fb & 0x80) == 0x80) value = -value;\n  return value;\n}; ///--- Exported API\n\n\nmodule.exports = Reader;","map":{"version":3,"sources":["/home/hayaz/haya/haya/hosters.pk/node_modules/asn1/lib/ber/reader.js"],"names":["assert","require","ASN1","errors","newInvalidAsn1Error","Reader","data","Buffer","isBuffer","TypeError","_buf","_size","length","_len","_offset","self","__defineGetter__","slice","prototype","readByte","peek","b","readLength","offset","undefined","lenB","i","readSequence","tag","seq","toString","o","readInt","_readTag","Integer","readBoolean","Boolean","readEnumeration","Enumeration","readString","retbuf","OctetString","str","readOID","OID","values","value","byte","push","shift","unshift","join","ok","fb","module","exports"],"mappings":"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","sourcesContent":["// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n///--- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n///--- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n\n  var self = this;\n  this.__defineGetter__('length', function() { return self._len; });\n  this.__defineGetter__('offset', function() { return self._offset; });\n  this.__defineGetter__('remain', function() {\n    return self._size - self._offset;\n  });\n  this.__defineGetter__('buffer', function() {\n    return self._buf.slice(self._offset);\n  });\n}\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function(peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function() {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function(offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) == 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB == 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function(tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function() {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function() {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function() {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function(tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function(tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    var byte = this._buf[this._offset++] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) == 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function(tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset++];\n  var value = 0;\n\n  value = fb & 0x7F;\n  for (var i = 1; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) == 0x80)\n    value = -value;\n\n  return value;\n};\n\n\n\n///--- Exported API\n\nmodule.exports = Reader;\n"]},"metadata":{},"sourceType":"script"}