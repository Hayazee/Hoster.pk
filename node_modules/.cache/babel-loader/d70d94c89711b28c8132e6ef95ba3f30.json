{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = require('assert-plus');\n\nvar crypto = require('crypto');\n\nvar http = require('http');\n\nvar sprintf = require('util').format; ///--- Globals\n\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\nvar Authorization = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\" %s'; ///--- Specific Errors\n\nfunction MissingHeaderError(message) {\n  this.name = 'MissingHeaderError';\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nMissingHeaderError.prototype = new Error();\n\nfunction InvalidAlgorithmError(message) {\n  this.name = 'InvalidAlgorithmError';\n  this.message = message;\n  this.stack = new Error().stack;\n}\n\nInvalidAlgorithmError.prototype = new Error(); ///--- Internal Functions\n\nfunction _pad(val) {\n  if (parseInt(val, 10) < 10) {\n    val = '0' + val;\n  }\n\n  return val;\n}\n\nfunction _rfc1123() {\n  var date = new Date();\n  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  return days[date.getUTCDay()] + ', ' + _pad(date.getUTCDate()) + ' ' + months[date.getUTCMonth()] + ' ' + date.getUTCFullYear() + ' ' + _pad(date.getUTCHours()) + ':' + _pad(date.getUTCMinutes()) + ':' + _pad(date.getUTCSeconds()) + ' GMT';\n} ///--- Exported API\n\n\nmodule.exports = {\n  /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */\n  signRequest: function signRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(options, 'options');\n    assert.optionalString(options.algorithm, 'options.algorithm');\n    assert.string(options.keyId, 'options.keyId');\n    assert.optionalArrayOfString(options.headers, 'options.headers');\n    if (!request.getHeader('Date')) request.setHeader('Date', _rfc1123());\n    if (!options.headers) options.headers = ['date'];\n    if (!options.algorithm) options.algorithm = 'rsa-sha256';\n    options.algorithm = options.algorithm.toLowerCase();\n    if (!Algorithms[options.algorithm]) throw new InvalidAlgorithmError(options.algorithm + ' is not supported');\n    var i;\n    var stringToSign = '';\n\n    for (i = 0; i < options.headers.length; i++) {\n      if (typeof options.headers[i] !== 'string') throw new TypeError('options.headers must be an array of Strings');\n      var h = options.headers[i].toLowerCase();\n      request.getHeader(h);\n      var value = request.getHeader(h);\n\n      if (!value) {\n        if (h === 'request-line') {\n          value = request.method + ' ' + request.path + ' HTTP/1.1';\n        } else {\n          throw new MissingHeaderError(h + ' was not in the request');\n        }\n      }\n\n      stringToSign += value;\n      if (i + 1 < options.headers.length) stringToSign += '\\n';\n    }\n\n    var alg = options.algorithm.match(/(hmac|rsa)-(\\w+)/);\n    var signature;\n\n    if (alg[1] === 'hmac') {\n      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);\n      hmac.update(stringToSign);\n      signature = hmac.digest('base64');\n    } else {\n      var signer = crypto.createSign(options.algorithm.toUpperCase());\n      signer.update(stringToSign);\n      signature = signer.sign(options.key, 'base64');\n    }\n\n    request.setHeader('Authorization', sprintf(Authorization, options.keyId, options.algorithm, options.headers.join(' '), signature));\n    return true;\n  }\n};","map":{"version":3,"sources":["/home/hayaz/haya/haya/hosters.pk/node_modules/http-signature/lib/signer.js"],"names":["assert","require","crypto","http","sprintf","format","Algorithms","Authorization","MissingHeaderError","message","name","stack","Error","prototype","InvalidAlgorithmError","_pad","val","parseInt","_rfc1123","date","Date","months","days","getUTCDay","getUTCDate","getUTCMonth","getUTCFullYear","getUTCHours","getUTCMinutes","getUTCSeconds","module","exports","signRequest","request","options","object","optionalString","algorithm","string","keyId","optionalArrayOfString","headers","getHeader","setHeader","toLowerCase","i","stringToSign","length","TypeError","h","value","method","path","alg","match","signature","hmac","createHmac","toUpperCase","key","update","digest","signer","createSign","sign","join"],"mappings":"AAAA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAApB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AAEA,IAAIG,OAAO,GAAGH,OAAO,CAAC,MAAD,CAAP,CAAgBI,MAA9B,C,CAIA;;;AAEA,IAAIC,UAAU,GAAG;AACf,cAAY,IADG;AAEf,gBAAc,IAFC;AAGf,gBAAc,IAHC;AAIf,cAAY,IAJG;AAKf,eAAa,IALE;AAMf,iBAAe,IANA;AAOf,iBAAe;AAPA,CAAjB;AAUA,IAAIC,aAAa,GAAG,qDAApB,C,CAIA;;AAEA,SAASC,kBAAT,CAA4BC,OAA5B,EAAqC;AACjC,OAAKC,IAAL,GAAY,oBAAZ;AACA,OAAKD,OAAL,GAAeA,OAAf;AACA,OAAKE,KAAL,GAAc,IAAIC,KAAJ,EAAD,CAAcD,KAA3B;AACH;;AACDH,kBAAkB,CAACK,SAAnB,GAA+B,IAAID,KAAJ,EAA/B;;AAGA,SAASE,qBAAT,CAA+BL,OAA/B,EAAwC;AACpC,OAAKC,IAAL,GAAY,uBAAZ;AACA,OAAKD,OAAL,GAAeA,OAAf;AACA,OAAKE,KAAL,GAAc,IAAIC,KAAJ,EAAD,CAAcD,KAA3B;AACH;;AACDG,qBAAqB,CAACD,SAAtB,GAAkC,IAAID,KAAJ,EAAlC,C,CAIA;;AAEA,SAASG,IAAT,CAAcC,GAAd,EAAmB;AACjB,MAAIC,QAAQ,CAACD,GAAD,EAAM,EAAN,CAAR,GAAoB,EAAxB,EAA4B;AAC1BA,IAAAA,GAAG,GAAG,MAAMA,GAAZ;AACD;;AACD,SAAOA,GAAP;AACD;;AAGD,SAASE,QAAT,GAAoB;AAClB,MAAIC,IAAI,GAAG,IAAIC,IAAJ,EAAX;AAEA,MAAIC,MAAM,GAAG,CAAC,KAAD,EACC,KADD,EAEC,KAFD,EAGC,KAHD,EAIC,KAJD,EAKC,KALD,EAMC,KAND,EAOC,KAPD,EAQC,KARD,EASC,KATD,EAUC,KAVD,EAWC,KAXD,CAAb;AAYA,MAAIC,IAAI,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,KAAtB,EAA6B,KAA7B,EAAoC,KAApC,EAA2C,KAA3C,CAAX;AACA,SAAOA,IAAI,CAACH,IAAI,CAACI,SAAL,EAAD,CAAJ,GAAyB,IAAzB,GACLR,IAAI,CAACI,IAAI,CAACK,UAAL,EAAD,CADC,GACqB,GADrB,GAELH,MAAM,CAACF,IAAI,CAACM,WAAL,EAAD,CAFD,GAEwB,GAFxB,GAGLN,IAAI,CAACO,cAAL,EAHK,GAGmB,GAHnB,GAILX,IAAI,CAACI,IAAI,CAACQ,WAAL,EAAD,CAJC,GAIsB,GAJtB,GAKLZ,IAAI,CAACI,IAAI,CAACS,aAAL,EAAD,CALC,GAKwB,GALxB,GAMLb,IAAI,CAACI,IAAI,CAACU,aAAL,EAAD,CANC,GAOL,MAPF;AAQD,C,CAID;;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AAEf;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACEC,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBC,OAArB,EAA8BC,OAA9B,EAAuC;AAClDlC,IAAAA,MAAM,CAACmC,MAAP,CAAcF,OAAd,EAAuB,SAAvB;AACAjC,IAAAA,MAAM,CAACmC,MAAP,CAAcD,OAAd,EAAuB,SAAvB;AACAlC,IAAAA,MAAM,CAACoC,cAAP,CAAsBF,OAAO,CAACG,SAA9B,EAAyC,mBAAzC;AACArC,IAAAA,MAAM,CAACsC,MAAP,CAAcJ,OAAO,CAACK,KAAtB,EAA6B,eAA7B;AACAvC,IAAAA,MAAM,CAACwC,qBAAP,CAA6BN,OAAO,CAACO,OAArC,EAA8C,iBAA9C;AAEA,QAAI,CAACR,OAAO,CAACS,SAAR,CAAkB,MAAlB,CAAL,EACET,OAAO,CAACU,SAAR,CAAkB,MAAlB,EAA0BzB,QAAQ,EAAlC;AACF,QAAI,CAACgB,OAAO,CAACO,OAAb,EACEP,OAAO,CAACO,OAAR,GAAkB,CAAC,MAAD,CAAlB;AACF,QAAI,CAACP,OAAO,CAACG,SAAb,EACEH,OAAO,CAACG,SAAR,GAAoB,YAApB;AAEFH,IAAAA,OAAO,CAACG,SAAR,GAAoBH,OAAO,CAACG,SAAR,CAAkBO,WAAlB,EAApB;AAEA,QAAI,CAACtC,UAAU,CAAC4B,OAAO,CAACG,SAAT,CAAf,EACE,MAAM,IAAIvB,qBAAJ,CAA0BoB,OAAO,CAACG,SAAR,GAAoB,mBAA9C,CAAN;AAEF,QAAIQ,CAAJ;AACA,QAAIC,YAAY,GAAG,EAAnB;;AACA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,OAAO,CAACO,OAAR,CAAgBM,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;AAC3C,UAAI,OAAQX,OAAO,CAACO,OAAR,CAAgBI,CAAhB,CAAR,KAAgC,QAApC,EACE,MAAM,IAAIG,SAAJ,CAAc,6CAAd,CAAN;AAEF,UAAIC,CAAC,GAAGf,OAAO,CAACO,OAAR,CAAgBI,CAAhB,EAAmBD,WAAnB,EAAR;AACAX,MAAAA,OAAO,CAACS,SAAR,CAAkBO,CAAlB;AAEA,UAAIC,KAAK,GAAGjB,OAAO,CAACS,SAAR,CAAkBO,CAAlB,CAAZ;;AACA,UAAI,CAACC,KAAL,EAAY;AACV,YAAID,CAAC,KAAK,cAAV,EAA0B;AACxBC,UAAAA,KAAK,GAAGjB,OAAO,CAACkB,MAAR,GAAiB,GAAjB,GAAuBlB,OAAO,CAACmB,IAA/B,GAAsC,WAA9C;AACD,SAFD,MAEO;AACL,gBAAM,IAAI5C,kBAAJ,CAAuByC,CAAC,GAAG,yBAA3B,CAAN;AACD;AACF;;AAEDH,MAAAA,YAAY,IAAII,KAAhB;AACA,UAAKL,CAAC,GAAG,CAAL,GAAUX,OAAO,CAACO,OAAR,CAAgBM,MAA9B,EACED,YAAY,IAAI,IAAhB;AACH;;AAED,QAAIO,GAAG,GAAGnB,OAAO,CAACG,SAAR,CAAkBiB,KAAlB,CAAwB,kBAAxB,CAAV;AACA,QAAIC,SAAJ;;AACA,QAAIF,GAAG,CAAC,CAAD,CAAH,KAAW,MAAf,EAAuB;AACrB,UAAIG,IAAI,GAAGtD,MAAM,CAACuD,UAAP,CAAkBJ,GAAG,CAAC,CAAD,CAAH,CAAOK,WAAP,EAAlB,EAAwCxB,OAAO,CAACyB,GAAhD,CAAX;AACAH,MAAAA,IAAI,CAACI,MAAL,CAAYd,YAAZ;AACAS,MAAAA,SAAS,GAAGC,IAAI,CAACK,MAAL,CAAY,QAAZ,CAAZ;AACD,KAJD,MAIO;AACL,UAAIC,MAAM,GAAG5D,MAAM,CAAC6D,UAAP,CAAkB7B,OAAO,CAACG,SAAR,CAAkBqB,WAAlB,EAAlB,CAAb;AACAI,MAAAA,MAAM,CAACF,MAAP,CAAcd,YAAd;AACAS,MAAAA,SAAS,GAAGO,MAAM,CAACE,IAAP,CAAY9B,OAAO,CAACyB,GAApB,EAAyB,QAAzB,CAAZ;AACD;;AAED1B,IAAAA,OAAO,CAACU,SAAR,CAAkB,eAAlB,EAAmCvC,OAAO,CAACG,aAAD,EACC2B,OAAO,CAACK,KADT,EAECL,OAAO,CAACG,SAFT,EAGCH,OAAO,CAACO,OAAR,CAAgBwB,IAAhB,CAAqB,GAArB,CAHD,EAICV,SAJD,CAA1C;AAMA,WAAO,IAAP;AACD;AArFc,CAAjB","sourcesContent":["// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar crypto = require('crypto');\nvar http = require('http');\n\nvar sprintf = require('util').format;\n\n\n\n///--- Globals\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\n\nvar Authorization = 'Signature keyId=\"%s\",algorithm=\"%s\",headers=\"%s\" %s';\n\n\n\n///--- Specific Errors\n\nfunction MissingHeaderError(message) {\n    this.name = 'MissingHeaderError';\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nMissingHeaderError.prototype = new Error();\n\n\nfunction InvalidAlgorithmError(message) {\n    this.name = 'InvalidAlgorithmError';\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nInvalidAlgorithmError.prototype = new Error();\n\n\n\n///--- Internal Functions\n\nfunction _pad(val) {\n  if (parseInt(val, 10) < 10) {\n    val = '0' + val;\n  }\n  return val;\n}\n\n\nfunction _rfc1123() {\n  var date = new Date();\n\n  var months = ['Jan',\n                'Feb',\n                'Mar',\n                'Apr',\n                'May',\n                'Jun',\n                'Jul',\n                'Aug',\n                'Sep',\n                'Oct',\n                'Nov',\n                'Dec'];\n  var days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  return days[date.getUTCDay()] + ', ' +\n    _pad(date.getUTCDate()) + ' ' +\n    months[date.getUTCMonth()] + ' ' +\n    date.getUTCFullYear() + ' ' +\n    _pad(date.getUTCHours()) + ':' +\n    _pad(date.getUTCMinutes()) + ':' +\n    _pad(date.getUTCSeconds()) +\n    ' GMT';\n}\n\n\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Adds an 'Authorization' header to an http.ClientRequest object.\n   *\n   * Note that this API will add a Date header if it's not already set. Any\n   * other headers in the options.headers array MUST be present, or this\n   * will throw.\n   *\n   * You shouldn't need to check the return type; it's just there if you want\n   * to be pedantic.\n   *\n   * @param {Object} request an instance of http.ClientRequest.\n   * @param {Object} options signing parameters object:\n   *                   - {String} keyId required.\n   *                   - {String} key required (either a PEM or HMAC key).\n   *                   - {Array} headers optional; defaults to ['date'].\n   *                   - {String} algorithm optional; defaults to 'rsa-sha256'.\n   * @return {Boolean} true if Authorization (and optionally Date) were added.\n   * @throws {TypeError} on bad parameter types (input).\n   * @throws {InvalidAlgorithmError} if algorithm was bad.\n   * @throws {MissingHeaderError} if a header to be signed was specified but\n   *                              was not present.\n   */\n  signRequest: function signRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(options, 'options');\n    assert.optionalString(options.algorithm, 'options.algorithm');\n    assert.string(options.keyId, 'options.keyId');\n    assert.optionalArrayOfString(options.headers, 'options.headers');\n\n    if (!request.getHeader('Date'))\n      request.setHeader('Date', _rfc1123());\n    if (!options.headers)\n      options.headers = ['date'];\n    if (!options.algorithm)\n      options.algorithm = 'rsa-sha256';\n\n    options.algorithm = options.algorithm.toLowerCase();\n\n    if (!Algorithms[options.algorithm])\n      throw new InvalidAlgorithmError(options.algorithm + ' is not supported');\n\n    var i;\n    var stringToSign = '';\n    for (i = 0; i < options.headers.length; i++) {\n      if (typeof (options.headers[i]) !== 'string')\n        throw new TypeError('options.headers must be an array of Strings');\n\n      var h = options.headers[i].toLowerCase();\n      request.getHeader(h);\n\n      var value = request.getHeader(h);\n      if (!value) {\n        if (h === 'request-line') {\n          value = request.method + ' ' + request.path + ' HTTP/1.1';\n        } else {\n          throw new MissingHeaderError(h + ' was not in the request');\n        }\n      }\n\n      stringToSign += value;\n      if ((i + 1) < options.headers.length)\n        stringToSign += '\\n';\n    }\n\n    var alg = options.algorithm.match(/(hmac|rsa)-(\\w+)/);\n    var signature;\n    if (alg[1] === 'hmac') {\n      var hmac = crypto.createHmac(alg[2].toUpperCase(), options.key);\n      hmac.update(stringToSign);\n      signature = hmac.digest('base64');\n    } else {\n      var signer = crypto.createSign(options.algorithm.toUpperCase());\n      signer.update(stringToSign);\n      signature = signer.sign(options.key, 'base64');\n    }\n\n    request.setHeader('Authorization', sprintf(Authorization,\n                                               options.keyId,\n                                               options.algorithm,\n                                               options.headers.join(' '),\n                                               signature));\n\n    return true;\n  }\n\n};\n"]},"metadata":{},"sourceType":"script"}