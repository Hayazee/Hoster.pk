{"ast":null,"code":"/*\n * ctf.js\n *\n * Understand and parse all of the different JSON formats of CTF data and\n * translate that into a series of node-ctype friendly pieces. The reason for\n * the abstraction is to handle different changes in the file format.\n *\n * We have to be careful here that we don't end up using a name that is already\n * a built in type.\n */\nvar mod_assert = require('assert');\n\nvar ASSERT = mod_assert.ok;\nvar ctf_versions = ['1.0'];\nvar ctf_entries = ['integer', 'float', 'typedef', 'struct'];\nvar ctf_deftypes = ['int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t', 'uint32_t', 'float', 'double'];\n\nfunction ctfParseInteger(entry, ctype) {\n  var name, sign, len, type;\n  name = entry['name'];\n  if (!('signed' in entry['integer'])) throw new Error('Malformed CTF JSON: integer missing ' + 'signed value');\n  if (!('length' in entry['integer'])) throw new Error('Malformed CTF JSON: integer missing ' + 'length value');\n  sign = entry['integer']['signed'];\n  len = entry['integer']['length'];\n  type = null;\n  if (sign && len == 1) type = 'int8_t';else if (len == 1) type = 'uint8_t';else if (sign && len == 2) type = 'int16_t';else if (len == 2) type = 'uint16_t';else if (sign && len == 4) type = 'int32_t';else if (len == 4) type = 'uint32_t';else if (sign && len == 8) type = 'int64_t';else if (len == 8) type = 'uint64_t';\n  if (type === null) throw new Error('Malformed CTF JSON: integer has ' + 'unsupported length and sign - ' + len + '/' + sign);\n  /*\n   * This means that this is the same as one of our built in types. If\n   * that's the case defining it would be an error. So instead of trying\n   * to typedef it, we'll return here.\n   */\n\n  if (name == type) return;\n\n  if (name == 'char') {\n    ASSERT(type == 'int8_t');\n    return;\n  }\n\n  ctype.typedef(name, type);\n}\n\nfunction ctfParseFloat(entry, ctype) {\n  var name, len;\n  name = entry['name'];\n  if (!('length' in entry['float'])) throw new Error('Malformed CTF JSON: float missing ' + 'length value');\n  len = entry['float']['length'];\n  if (len != 4 && len != 8) throw new Error('Malformed CTF JSON: float has invalid ' + 'length value');\n\n  if (len == 4) {\n    if (name == 'float') return;\n    ctype.typedef(name, 'float');\n  } else if (len == 8) {\n    if (name == 'double') return;\n    ctype.typedef(name, 'double');\n  }\n}\n\nfunction ctfParseTypedef(entry, ctype) {\n  var name, type, ii;\n  name = entry['name'];\n  if (typeof entry['typedef'] != 'string') throw new Error('Malformed CTF JSON: typedef value in not ' + 'a string');\n  type = entry['typedef'];\n  /*\n   * We need to ensure that we're not looking at type that's one of our\n   * built in types. Traditionally in C a uint32_t would be a typedef to\n   * some kind of integer. However, those size types are built ins.\n   */\n\n  for (ii = 0; ii < ctf_deftypes.length; ii++) {\n    if (name == ctf_deftypes[ii]) return;\n  }\n\n  ctype.typedef(name, type);\n}\n\nfunction ctfParseStruct(entry, ctype) {\n  var name, type, ii, val, index, member, push;\n  member = [];\n  if (!Array.isArray(entry['struct'])) throw new Error('Malformed CTF JSON: struct value is not ' + 'an array');\n\n  for (ii = 0; ii < entry['struct'].length; ii++) {\n    val = entry['struct'][ii];\n    if (!('name' in val)) throw new Error('Malformed CTF JSON: struct member ' + 'missing name');\n    if (!('type' in val)) throw new Error('Malformed CTF JSON: struct member ' + 'missing type');\n    if (typeof val['name'] != 'string') throw new Error('Malformed CTF JSON: struct member ' + 'name isn\\'t a string');\n    if (typeof val['type'] != 'string') throw new Error('Malformed CTF JSON: struct member ' + 'type isn\\'t a string');\n    /*\n     * CTF version 2 specifies array names as <type> [<num>] where\n     * as node-ctype does this as <type>[<num>].\n     */\n\n    name = val['name'];\n    type = val['type'];\n    index = type.indexOf(' [');\n\n    if (index != -1) {\n      type = type.substring(0, index) + type.substring(index + 1, type.length);\n    }\n\n    push = {};\n    push[name] = {\n      'type': type\n    };\n    member.push(push);\n  }\n\n  name = entry['name'];\n  ctype.typedef(name, member);\n}\n\nfunction ctfParseEntry(entry, ctype) {\n  var ii, found;\n  if (!('name' in entry)) throw new Error('Malformed CTF JSON: entry missing \"name\" ' + 'section');\n\n  for (ii = 0; ii < ctf_entries.length; ii++) {\n    if (ctf_entries[ii] in entry) found++;\n  }\n\n  if (found === 0) throw new Error('Malformed CTF JSON: found no entries');\n  if (found >= 2) throw new Error('Malformed CTF JSON: found more than one ' + 'entry');\n\n  if ('integer' in entry) {\n    ctfParseInteger(entry, ctype);\n    return;\n  }\n\n  if ('float' in entry) {\n    ctfParseFloat(entry, ctype);\n    return;\n  }\n\n  if ('typedef' in entry) {\n    ctfParseTypedef(entry, ctype);\n    return;\n  }\n\n  if ('struct' in entry) {\n    ctfParseStruct(entry, ctype);\n    return;\n  }\n\n  ASSERT(false, 'shouldn\\'t reach here');\n}\n\nfunction ctfParseJson(json, ctype) {\n  var version, ii;\n  ASSERT(json);\n  ASSERT(ctype);\n  if (!('metadata' in json)) throw new Error('Invalid CTF JSON: missing metadata section');\n  if (!('ctf2json_version' in json['metadata'])) throw new Error('Invalid CTF JSON: missing ctf2json_version');\n  version = json['metadata']['ctf2json_version'];\n\n  for (ii = 0; ii < ctf_versions.length; ii++) {\n    if (ctf_versions[ii] == version) break;\n  }\n\n  if (ii == ctf_versions.length) throw new Error('Unsuported ctf2json_version: ' + version);\n  if (!('data' in json)) throw new Error('Invalid CTF JSON: missing data section');\n  if (!Array.isArray(json['data'])) throw new Error('Malformed CTF JSON: data section is not ' + 'an array');\n\n  for (ii = 0; ii < json['data'].length; ii++) ctfParseEntry(json['data'][ii], ctype);\n}\n\nexports.ctfParseJson = ctfParseJson;","map":{"version":3,"sources":["/home/hayaz/haya/haya/hosters.pk/node_modules/ctype/ctf.js"],"names":["mod_assert","require","ASSERT","ok","ctf_versions","ctf_entries","ctf_deftypes","ctfParseInteger","entry","ctype","name","sign","len","type","Error","typedef","ctfParseFloat","ctfParseTypedef","ii","length","ctfParseStruct","val","index","member","push","Array","isArray","indexOf","substring","ctfParseEntry","found","ctfParseJson","json","version","exports"],"mappings":"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","sourcesContent":["/*\n * ctf.js\n *\n * Understand and parse all of the different JSON formats of CTF data and\n * translate that into a series of node-ctype friendly pieces. The reason for\n * the abstraction is to handle different changes in the file format.\n *\n * We have to be careful here that we don't end up using a name that is already\n * a built in type.\n */\nvar mod_assert = require('assert');\nvar ASSERT = mod_assert.ok;\n\nvar ctf_versions = [ '1.0' ];\nvar ctf_entries = [ 'integer', 'float', 'typedef', 'struct' ];\nvar ctf_deftypes = [ 'int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',\n    'uint32_t', 'float', 'double' ];\n\nfunction ctfParseInteger(entry, ctype)\n{\n\tvar name, sign, len, type;\n\n\tname = entry['name'];\n\tif (!('signed' in entry['integer']))\n\t\tthrow (new Error('Malformed CTF JSON: integer missing ' +\n\t\t    'signed value'));\n\n\n\tif (!('length' in entry['integer']))\n\t\tthrow (new Error('Malformed CTF JSON: integer missing ' +\n\t\t    'length value'));\n\n\tsign = entry['integer']['signed'];\n\tlen = entry['integer']['length'];\n\ttype = null;\n\n\tif (sign && len == 1)\n\t\ttype = 'int8_t';\n\telse if (len == 1)\n\t\ttype = 'uint8_t';\n\telse if (sign && len == 2)\n\t\ttype = 'int16_t';\n\telse if (len == 2)\n\t\ttype = 'uint16_t';\n\telse if (sign && len == 4)\n\t\ttype = 'int32_t';\n\telse if (len == 4)\n\t\ttype = 'uint32_t';\n\telse if (sign && len == 8)\n\t\ttype = 'int64_t';\n\telse if (len == 8)\n\t\ttype = 'uint64_t';\n\n\tif (type === null)\n\t\tthrow (new Error('Malformed CTF JSON: integer has ' +\n\t\t    'unsupported length and sign - ' + len + '/' + sign));\n\n\t/*\n\t * This means that this is the same as one of our built in types. If\n\t * that's the case defining it would be an error. So instead of trying\n\t * to typedef it, we'll return here.\n\t */\n\tif (name == type)\n\t\treturn;\n\n\tif (name == 'char') {\n\t\tASSERT(type == 'int8_t');\n\t\treturn;\n\t}\n\n\tctype.typedef(name, type);\n}\n\nfunction ctfParseFloat(entry, ctype)\n{\n\tvar name, len;\n\n\tname = entry['name'];\n\tif (!('length' in entry['float']))\n\t\tthrow (new Error('Malformed CTF JSON: float missing ' +\n\t\t    'length value'));\n\n\tlen = entry['float']['length'];\n\tif (len != 4 && len != 8)\n\t\tthrow (new Error('Malformed CTF JSON: float has invalid ' +\n\t\t    'length value'));\n\n\tif (len == 4) {\n\t\tif (name == 'float')\n\t\t\treturn;\n\t\tctype.typedef(name, 'float');\n\t} else if (len == 8) {\n\t\tif (name == 'double')\n\t\t\treturn;\n\t\tctype.typedef(name, 'double');\n\t}\n}\n\nfunction ctfParseTypedef(entry, ctype)\n{\n\tvar name, type, ii;\n\n\tname = entry['name'];\n\tif (typeof (entry['typedef']) != 'string')\n\t\tthrow (new Error('Malformed CTF JSON: typedef value in not ' +\n\t\t    'a string'));\n\n\ttype = entry['typedef'];\n\n\t/*\n\t * We need to ensure that we're not looking at type that's one of our\n\t * built in types. Traditionally in C a uint32_t would be a typedef to\n\t * some kind of integer. However, those size types are built ins.\n\t */\n\tfor (ii = 0; ii < ctf_deftypes.length; ii++) {\n\t\tif (name == ctf_deftypes[ii])\n\t\t\treturn;\n\t}\n\n\tctype.typedef(name, type);\n}\n\nfunction ctfParseStruct(entry, ctype)\n{\n\tvar name, type, ii, val, index, member, push;\n\n\tmember = [];\n\tif (!Array.isArray(entry['struct']))\n\t\tthrow (new Error('Malformed CTF JSON: struct value is not ' +\n\t\t    'an array'));\n\n\tfor (ii = 0; ii < entry['struct'].length; ii++) {\n\t\tval = entry['struct'][ii];\n\t\tif (!('name' in val))\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'missing name'));\n\n\t\tif (!('type' in val))\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'missing type'));\n\n\t\tif (typeof (val['name']) != 'string')\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'name isn\\'t a string'));\n\n\t\tif (typeof (val['type']) != 'string')\n\t\t\tthrow (new Error('Malformed CTF JSON: struct member ' +\n\t\t\t    'type isn\\'t a string'));\n\n\t\t/*\n\t\t * CTF version 2 specifies array names as <type> [<num>] where\n\t\t * as node-ctype does this as <type>[<num>].\n\t\t */\n\t\tname = val['name'];\n\t\ttype = val['type'];\n\t\tindex = type.indexOf(' [');\n\t\tif (index != -1) {\n\t\t\ttype = type.substring(0, index) +\n\t\t\t    type.substring(index + 1, type.length);\n\t\t}\n\t\tpush = {};\n\t\tpush[name] = { 'type': type };\n\t\tmember.push(push);\n\t}\n\n\tname = entry['name'];\n\tctype.typedef(name, member);\n}\n\nfunction ctfParseEntry(entry, ctype)\n{\n\tvar ii, found;\n\n\tif (!('name' in entry))\n\t\tthrow (new Error('Malformed CTF JSON: entry missing \"name\" ' +\n\t\t    'section'));\n\n\tfor (ii = 0; ii < ctf_entries.length; ii++) {\n\t\tif (ctf_entries[ii] in entry)\n\t\t\tfound++;\n\t}\n\n\tif (found === 0)\n\t\tthrow (new Error('Malformed CTF JSON: found no entries'));\n\n\tif (found >= 2)\n\t\tthrow (new Error('Malformed CTF JSON: found more than one ' +\n\t\t    'entry'));\n\n\tif ('integer' in entry) {\n\t\tctfParseInteger(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('float' in entry) {\n\t\tctfParseFloat(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('typedef' in entry) {\n\t\tctfParseTypedef(entry, ctype);\n\t\treturn;\n\t}\n\n\tif ('struct' in entry) {\n\t\tctfParseStruct(entry, ctype);\n\t\treturn;\n\t}\n\n\tASSERT(false, 'shouldn\\'t reach here');\n}\n\nfunction ctfParseJson(json, ctype)\n{\n\tvar version, ii;\n\n\tASSERT(json);\n\tASSERT(ctype);\n\tif (!('metadata' in json))\n\t\tthrow (new Error('Invalid CTF JSON: missing metadata section'));\n\n\tif (!('ctf2json_version' in json['metadata']))\n\t\tthrow (new Error('Invalid CTF JSON: missing ctf2json_version'));\n\n\tversion = json['metadata']['ctf2json_version'];\n\tfor (ii = 0; ii < ctf_versions.length; ii++) {\n\t\tif (ctf_versions[ii] == version)\n\t\t\tbreak;\n\t}\n\n\tif (ii == ctf_versions.length)\n\t\tthrow (new Error('Unsuported ctf2json_version: ' + version));\n\n\tif (!('data' in json))\n\t\tthrow (new Error('Invalid CTF JSON: missing data section'));\n\n\tif (!Array.isArray(json['data']))\n\t\tthrow (new Error('Malformed CTF JSON: data section is not ' +\n\t\t    'an array'));\n\n\tfor (ii = 0; ii < json['data'].length; ii++)\n\t\tctfParseEntry(json['data'][ii], ctype);\n}\n\nexports.ctfParseJson = ctfParseJson;\n"]},"metadata":{},"sourceType":"script"}