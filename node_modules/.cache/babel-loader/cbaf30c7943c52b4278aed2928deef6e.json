{"ast":null,"code":"// Copyright 2012 Joyent, Inc.  All rights reserved.\nvar assert = require('assert-plus');\n\nvar util = require('util'); ///--- Globals\n\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\nvar State = {\n  New: 0,\n  Params: 1,\n  Signature: 2\n};\nvar ParamsState = {\n  Name: 0,\n  Value: 1\n}; ///--- Specific Errors\n\nfunction HttpSignatureError(message, caller) {\n  if (Error.captureStackTrace) Error.captureStackTrace(this, caller || HttpSignatureError);\n  this.message = message;\n  this.name = caller.name;\n}\n\nutil.inherits(HttpSignatureError, Error);\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\n\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\n\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\n\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\n\nutil.inherits(MissingHeaderError, HttpSignatureError); ///--- Exported API\n\nmodule.exports = {\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"content-md5\"\n   *         ]\n   *       },\n   *       \"signature\": \"base64\",\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n\n    if (options === undefined) {\n      options = {};\n    }\n\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalNumber(options.clockSkew, 'options.clockSkew');\n    if (!request.headers.authorization) throw new MissingHeaderError('no authorization header present in ' + 'the request');\n    options.clockSkew = options.clockSkew || 300;\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n    var parsed = {\n      scheme: '',\n      params: {},\n      signature: '',\n      signingString: '',\n\n      get algorithm() {\n        return this.params.algorithm.toUpperCase();\n      },\n\n      get keyId() {\n        return this.params.keyId;\n      }\n\n    };\n    var authz = request.headers.authorization;\n\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n        case State.New:\n          if (c !== ' ') parsed.scheme += c;else state = State.Params;\n          break;\n\n        case State.Params:\n          switch (Number(substate)) {\n            case ParamsState.Name:\n              if (c === '\"') {\n                parsed.params[tmpName] = '';\n                tmpValue = '';\n                substate = ParamsState.Value;\n              } else if (c === ' ') {\n                state = State.Signature;\n              } else if (c !== '=' && c !== ',') {\n                tmpName += c;\n              }\n\n              break;\n\n            case ParamsState.Value:\n              if (c === '\"') {\n                parsed.params[tmpName] = tmpValue;\n                tmpName = '';\n                substate = ParamsState.Name;\n              } else {\n                tmpValue += c;\n              }\n\n              break;\n\n            default:\n              throw new Error('Invalid substate');\n          }\n\n          break;\n\n        case State.Signature:\n          parsed.signature += c;\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n      }\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    } // Minimally validate the parsed object\n\n\n    if (!parsed.scheme || parsed.scheme !== 'Signature') throw new InvalidHeaderError('scheme was not \"Signature\"');\n    if (!parsed.params.keyId) throw new InvalidHeaderError('keyId was not specified');\n    if (!parsed.params.algorithm) throw new InvalidHeaderError('algorithm was not specified');\n    if (!parsed.signature) throw new InvalidHeaderError('signature was empty'); // Check the algorithm against the official list\n\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (!Algorithms[parsed.params.algorithm]) throw new InvalidParamsError(parsed.params.algorithm + ' is not supported'); // Build the signingString\n\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n      var value;\n\n      if (h !== 'request-line') {\n        value = request.headers[h];\n        if (!value) throw new MissingHeaderError(h + ' was not in the request');\n      } else {\n        value = request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n      }\n\n      parsed.signingString += value;\n      if (i + 1 < parsed.params.headers.length) parsed.signingString += '\\n';\n    } // Check against the constraints\n\n\n    var date;\n\n    if (request.headers.date || request.headers['x-date']) {\n      if (request.headers['x-date']) {\n        date = new Date(request.headers['x-date']);\n      } else {\n        date = new Date(request.headers.date);\n      }\n\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' + skew / 1000 + 's was greater than ' + options.clockSkew + 's');\n      }\n    }\n\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr) < 0) throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1) throw new InvalidParamsError(parsed.params.algorithm + ' is not a supported algorithm');\n    }\n\n    return parsed;\n  }\n};","map":{"version":3,"sources":["/home/hayaz/haya/haya/hosters.pk/node_modules/http-signature/lib/parser.js"],"names":["assert","require","util","Algorithms","State","New","Params","Signature","ParamsState","Name","Value","HttpSignatureError","message","caller","Error","captureStackTrace","name","inherits","ExpiredRequestError","call","InvalidHeaderError","InvalidParamsError","MissingHeaderError","module","exports","parseRequest","request","options","object","headers","undefined","arrayOfString","optionalNumber","clockSkew","authorization","i","state","substate","tmpName","tmpValue","parsed","scheme","params","signature","signingString","algorithm","toUpperCase","keyId","authz","length","c","charAt","Number","split","toLowerCase","h","value","method","url","httpVersion","date","Date","now","skew","Math","abs","getTime","forEach","hdr","indexOf","algorithms"],"mappings":"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","sourcesContent":["// Copyright 2012 Joyent, Inc.  All rights reserved.\n\nvar assert = require('assert-plus');\nvar util = require('util');\n\n\n\n///--- Globals\n\nvar Algorithms = {\n  'rsa-sha1': true,\n  'rsa-sha256': true,\n  'rsa-sha512': true,\n  'dsa-sha1': true,\n  'hmac-sha1': true,\n  'hmac-sha256': true,\n  'hmac-sha512': true\n};\n\nvar State = {\n  New: 0,\n  Params: 1,\n  Signature: 2\n};\n\nvar ParamsState = {\n  Name: 0,\n  Value: 1\n};\n\n\n\n///--- Specific Errors\n\nfunction HttpSignatureError(message, caller) {\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(this, caller || HttpSignatureError);\n\n  this.message = message;\n  this.name = caller.name;\n}\nutil.inherits(HttpSignatureError, Error);\n\nfunction ExpiredRequestError(message) {\n  HttpSignatureError.call(this, message, ExpiredRequestError);\n}\nutil.inherits(ExpiredRequestError, HttpSignatureError);\n\n\nfunction InvalidHeaderError(message) {\n  HttpSignatureError.call(this, message, InvalidHeaderError);\n}\nutil.inherits(InvalidHeaderError, HttpSignatureError);\n\n\nfunction InvalidParamsError(message) {\n  HttpSignatureError.call(this, message, InvalidParamsError);\n}\nutil.inherits(InvalidParamsError, HttpSignatureError);\n\n\nfunction MissingHeaderError(message) {\n  HttpSignatureError.call(this, message, MissingHeaderError);\n}\nutil.inherits(MissingHeaderError, HttpSignatureError);\n\n\n\n///--- Exported API\n\nmodule.exports = {\n\n  /**\n   * Parses the 'Authorization' header out of an http.ServerRequest object.\n   *\n   * Note that this API will fully validate the Authorization header, and throw\n   * on any error.  It will not however check the signature, or the keyId format\n   * as those are specific to your environment.  You can use the options object\n   * to pass in extra constraints.\n   *\n   * As a response object you can expect this:\n   *\n   *     {\n   *       \"scheme\": \"Signature\",\n   *       \"params\": {\n   *         \"keyId\": \"foo\",\n   *         \"algorithm\": \"rsa-sha256\",\n   *         \"headers\": [\n   *           \"date\" or \"x-date\",\n   *           \"content-md5\"\n   *         ]\n   *       },\n   *       \"signature\": \"base64\",\n   *       \"signingString\": \"ready to be passed to crypto.verify()\"\n   *     }\n   *\n   * @param {Object} request an http.ServerRequest.\n   * @param {Object} options an optional options object with:\n   *                   - clockSkew: allowed clock skew in seconds (default 300).\n   *                   - headers: required header names (def: date or x-date)\n   *                   - algorithms: algorithms to support (default: all).\n   * @return {Object} parsed out object (see above).\n   * @throws {TypeError} on invalid input.\n   * @throws {InvalidHeaderError} on an invalid Authorization header error.\n   * @throws {InvalidParamsError} if the params in the scheme are invalid.\n   * @throws {MissingHeaderError} if the params indicate a header not present,\n   *                              either in the request headers from the params,\n   *                              or not in the params from a required header\n   *                              in options.\n   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.\n   */\n  parseRequest: function parseRequest(request, options) {\n    assert.object(request, 'request');\n    assert.object(request.headers, 'request.headers');\n    if (options === undefined) {\n      options = {};\n    }\n    if (options.headers === undefined) {\n      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];\n    }\n    assert.object(options, 'options');\n    assert.arrayOfString(options.headers, 'options.headers');\n    assert.optionalNumber(options.clockSkew, 'options.clockSkew');\n\n    if (!request.headers.authorization)\n      throw new MissingHeaderError('no authorization header present in ' +\n                                   'the request');\n\n    options.clockSkew = options.clockSkew || 300;\n\n\n    var i = 0;\n    var state = State.New;\n    var substate = ParamsState.Name;\n    var tmpName = '';\n    var tmpValue = '';\n\n    var parsed = {\n      scheme: '',\n      params: {},\n      signature: '',\n      signingString: '',\n\n      get algorithm() {\n        return this.params.algorithm.toUpperCase();\n      },\n\n      get keyId() {\n        return this.params.keyId;\n      }\n\n    };\n\n    var authz = request.headers.authorization;\n    for (i = 0; i < authz.length; i++) {\n      var c = authz.charAt(i);\n\n      switch (Number(state)) {\n\n      case State.New:\n        if (c !== ' ') parsed.scheme += c;\n        else state = State.Params;\n        break;\n\n      case State.Params:\n        switch (Number(substate)) {\n\n        case ParamsState.Name:\n          if (c === '\"') {\n            parsed.params[tmpName] = '';\n            tmpValue = '';\n            substate = ParamsState.Value;\n          } else if (c === ' ') {\n            state = State.Signature;\n          } else if (c !== '=' && c !== ',') {\n            tmpName += c;\n          }\n          break;\n\n        case ParamsState.Value:\n          if (c === '\"') {\n            parsed.params[tmpName] = tmpValue;\n            tmpName = '';\n            substate = ParamsState.Name;\n          } else {\n            tmpValue += c;\n          }\n          break;\n\n        default:\n          throw new Error('Invalid substate');\n        }\n        break;\n\n\n      case State.Signature:\n        parsed.signature += c;\n        break;\n\n      default:\n        throw new Error('Invalid substate');\n      }\n\n    }\n\n    if (!parsed.params.headers || parsed.params.headers === '') {\n      if (request.headers['x-date']) {\n        parsed.params.headers = ['x-date'];\n      } else {\n        parsed.params.headers = ['date'];\n      }\n    } else {\n      parsed.params.headers = parsed.params.headers.split(' ');\n    }\n\n    // Minimally validate the parsed object\n    if (!parsed.scheme || parsed.scheme !== 'Signature')\n      throw new InvalidHeaderError('scheme was not \"Signature\"');\n\n    if (!parsed.params.keyId)\n      throw new InvalidHeaderError('keyId was not specified');\n\n    if (!parsed.params.algorithm)\n      throw new InvalidHeaderError('algorithm was not specified');\n\n    if (!parsed.signature)\n      throw new InvalidHeaderError('signature was empty');\n\n    // Check the algorithm against the official list\n    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();\n    if (!Algorithms[parsed.params.algorithm])\n      throw new InvalidParamsError(parsed.params.algorithm +\n                                   ' is not supported');\n\n    // Build the signingString\n    for (i = 0; i < parsed.params.headers.length; i++) {\n      var h = parsed.params.headers[i].toLowerCase();\n      parsed.params.headers[i] = h;\n\n      var value;\n      if (h !== 'request-line') {\n        value = request.headers[h];\n        if (!value)\n          throw new MissingHeaderError(h + ' was not in the request');\n      } else {\n        value =\n          request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;\n      }\n\n      parsed.signingString += value;\n      if ((i + 1) < parsed.params.headers.length)\n        parsed.signingString += '\\n';\n    }\n\n    // Check against the constraints\n    var date;\n    if (request.headers.date || request.headers['x-date']) {\n        if (request.headers['x-date']) {\n          date = new Date(request.headers['x-date']);\n        } else {\n          date = new Date(request.headers.date);\n        }\n      var now = new Date();\n      var skew = Math.abs(now.getTime() - date.getTime());\n\n      if (skew > options.clockSkew * 1000) {\n        throw new ExpiredRequestError('clock skew of ' +\n                                      (skew / 1000) +\n                                      's was greater than ' +\n                                      options.clockSkew + 's');\n      }\n    }\n\n    options.headers.forEach(function (hdr) {\n      // Remember that we already checked any headers in the params\n      // were in the request, so if this passes we're good.\n      if (parsed.params.headers.indexOf(hdr) < 0)\n        throw new MissingHeaderError(hdr + ' was not a signed header');\n    });\n\n    if (options.algorithms) {\n      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)\n        throw new InvalidParamsError(parsed.params.algorithm +\n                                     ' is not a supported algorithm');\n    }\n\n    return parsed;\n  }\n\n};\n"]},"metadata":{},"sourceType":"script"}