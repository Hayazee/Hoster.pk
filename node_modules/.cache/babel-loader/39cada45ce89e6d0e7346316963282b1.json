{"ast":null,"code":"/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\nvar mod_ctf = require('./ctf.js');\n\nvar mod_ctio = require('./ctio.js');\n\nvar mod_assert = require('assert');\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\n\n\nvar deftypes = {\n  'uint8_t': {\n    read: ctReadUint8,\n    write: ctWriteUint8\n  },\n  'uint16_t': {\n    read: ctReadUint16,\n    write: ctWriteUint16\n  },\n  'uint32_t': {\n    read: ctReadUint32,\n    write: ctWriteUint32\n  },\n  'uint64_t': {\n    read: ctReadUint64,\n    write: ctWriteUint64\n  },\n  'int8_t': {\n    read: ctReadSint8,\n    write: ctWriteSint8\n  },\n  'int16_t': {\n    read: ctReadSint16,\n    write: ctWriteSint16\n  },\n  'int32_t': {\n    read: ctReadSint32,\n    write: ctWriteSint32\n  },\n  'int64_t': {\n    read: ctReadSint64,\n    write: ctWriteSint64\n  },\n  'float': {\n    read: ctReadFloat,\n    write: ctWriteFloat\n  },\n  'double': {\n    read: ctReadDouble,\n    write: ctWriteDouble\n  },\n  'char': {\n    read: ctReadChar,\n    write: ctWriteChar\n  },\n  'char[]': {\n    read: ctReadCharArray,\n    write: ctWriteCharArray\n  }\n};\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\n\nfunction ctReadUint8(endian, buffer, offset) {\n  var val = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\n\nfunction ctReadUint16(endian, buffer, offset) {\n  var val = mod_ctio.ruint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\n\nfunction ctReadUint32(endian, buffer, offset) {\n  var val = mod_ctio.ruint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadUint64(endian, buffer, offset) {\n  var val = mod_ctio.ruint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n\nfunction ctReadSint8(endian, buffer, offset) {\n  var val = mod_ctio.rsint8(buffer, endian, offset);\n  return {\n    value: val,\n    size: 1\n  };\n}\n\nfunction ctReadSint16(endian, buffer, offset) {\n  var val = mod_ctio.rsint16(buffer, endian, offset);\n  return {\n    value: val,\n    size: 2\n  };\n}\n\nfunction ctReadSint32(endian, buffer, offset) {\n  var val = mod_ctio.rsint32(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadSint64(endian, buffer, offset) {\n  var val = mod_ctio.rsint64(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n\nfunction ctReadFloat(endian, buffer, offset) {\n  var val = mod_ctio.rfloat(buffer, endian, offset);\n  return {\n    value: val,\n    size: 4\n  };\n}\n\nfunction ctReadDouble(endian, buffer, offset) {\n  var val = mod_ctio.rdouble(buffer, endian, offset);\n  return {\n    value: val,\n    size: 8\n  };\n}\n/*\n * Reads a single character into a node buffer\n */\n\n\nfunction ctReadChar(endian, buffer, offset) {\n  var res = new Buffer(1);\n  res[0] = mod_ctio.ruint8(buffer, endian, offset);\n  return {\n    value: res,\n    size: 1\n  };\n}\n\nfunction ctReadCharArray(length, endian, buffer, offset) {\n  var ii;\n  var res = new Buffer(length);\n\n  for (ii = 0; ii < length; ii++) res[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n\n  return {\n    value: res,\n    size: length\n  };\n}\n\nfunction ctWriteUint8(value, endian, buffer, offset) {\n  mod_ctio.wuint8(value, endian, buffer, offset);\n  return 1;\n}\n\nfunction ctWriteUint16(value, endian, buffer, offset) {\n  mod_ctio.wuint16(value, endian, buffer, offset);\n  return 2;\n}\n\nfunction ctWriteUint32(value, endian, buffer, offset) {\n  mod_ctio.wuint32(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteUint64(value, endian, buffer, offset) {\n  mod_ctio.wuint64(value, endian, buffer, offset);\n  return 8;\n}\n\nfunction ctWriteSint8(value, endian, buffer, offset) {\n  mod_ctio.wsint8(value, endian, buffer, offset);\n  return 1;\n}\n\nfunction ctWriteSint16(value, endian, buffer, offset) {\n  mod_ctio.wsint16(value, endian, buffer, offset);\n  return 2;\n}\n\nfunction ctWriteSint32(value, endian, buffer, offset) {\n  mod_ctio.wsint32(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteSint64(value, endian, buffer, offset) {\n  mod_ctio.wsint64(value, endian, buffer, offset);\n  return 8;\n}\n\nfunction ctWriteFloat(value, endian, buffer, offset) {\n  mod_ctio.wfloat(value, endian, buffer, offset);\n  return 4;\n}\n\nfunction ctWriteDouble(value, endian, buffer, offset) {\n  mod_ctio.wdouble(value, endian, buffer, offset);\n  return 8;\n}\n/*\n * Writes a single character into a node buffer\n */\n\n\nfunction ctWriteChar(value, endian, buffer, offset) {\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  mod_ctio.ruint8(value[0], endian, buffer, offset);\n  return 1;\n}\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\n\n\nfunction ctWriteCharArray(value, length, endian, buffer, offset) {\n  var ii;\n  if (!(value instanceof Buffer)) throw new Error('Input must be a buffer');\n  if (value.length > length) throw new Error('value length greater than array length');\n\n  for (ii = 0; ii < value.length && ii < length; ii++) mod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n\n  for (; ii < length; ii++) mod_ctio.wuint8(0, endian, offset + ii);\n\n  return length;\n}\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\n\n\nfunction ctGetBasicTypes() {\n  var ret = {};\n  var key;\n\n  for (key in deftypes) ret[key] = deftypes[key];\n\n  return ret;\n}\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\n\n\nfunction ctParseType(str) {\n  var begInd, endInd;\n  var type, len;\n  if (typeof str != 'string') throw new Error('type must be a Javascript string');\n  endInd = str.lastIndexOf(']');\n\n  if (endInd == -1) {\n    if (str.lastIndexOf('[') != -1) throw new Error('found invalid type with \\'[\\' but ' + 'no corresponding \\']\\'');\n    return {\n      type: str\n    };\n  }\n\n  begInd = str.lastIndexOf('[');\n  if (begInd == -1) throw new Error('found invalid type with \\']\\' but ' + 'no corresponding \\'[\\'');\n  if (begInd >= endInd) throw new Error('malformed type, \\']\\' appears before \\'[\\'');\n  type = str.substring(0, begInd);\n  len = str.substring(begInd + 1, endInd);\n  return {\n    type: type,\n    len: len\n  };\n}\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\n\n\nfunction ctCheckReq(def, types, fields) {\n  var ii, jj;\n  var req, keys, key;\n  var found = {};\n  if (!(def instanceof Array)) throw new Error('definition is not an array');\n  if (def.length === 0) throw new Error('definition must have at least one element');\n\n  for (ii = 0; ii < def.length; ii++) {\n    req = def[ii];\n    if (!(req instanceof Object)) throw new Error('definition must be an array of' + 'objects');\n    keys = Object.keys(req);\n    if (keys.length != 1) throw new Error('definition entry must only have ' + 'one key');\n    if (keys[0] in found) throw new Error('Specified name already ' + 'specified: ' + keys[0]);\n    if (!('type' in req[keys[0]])) throw new Error('missing required type definition');\n    key = ctParseType(req[keys[0]]['type']);\n    /*\n     * We may have nested arrays, we need to check the validity of\n     * the types until the len field is undefined in key. However,\n     * each time len is defined we need to verify it is either an\n     * integer or corresponds to an already seen key.\n     */\n\n    while (key['len'] !== undefined) {\n      if (isNaN(parseInt(key['len'], 10))) {\n        if (!(key['len'] in found)) throw new Error('Given an array ' + 'length without a matching type');\n      }\n\n      key = ctParseType(key['type']);\n    }\n    /* Now we can validate if the type is valid */\n\n\n    if (!(key['type'] in types)) throw new Error('type not found or typdefed: ' + key['type']);\n    /* Check for any required fields */\n\n    if (fields !== undefined) {\n      for (jj = 0; jj < fields.length; jj++) {\n        if (!(fields[jj] in req[keys[0]])) throw new Error('Missing required ' + 'field: ' + fields[jj]);\n      }\n    }\n\n    found[keys[0]] = true;\n  }\n}\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\n\n\nfunction CTypeParser(conf) {\n  if (!conf) throw new Error('missing required argument');\n  if (!('endian' in conf)) throw new Error('missing required endian value');\n  if (conf['endian'] != 'big' && conf['endian'] != 'little') throw new Error('Invalid endian type');\n  if ('char-type' in conf && conf['char-type'] != 'uint8' && conf['char-type'] != 'int8') throw new Error('invalid option for char-type: ' + conf['char-type']);\n  this.endian = conf['endian'];\n  this.types = ctGetBasicTypes();\n  /*\n   * There may be a more graceful way to do this, but this will have to\n   * serve.\n   */\n\n  if ('char-type' in conf && conf['char-type'] == 'uint8') this.types['char'] = this.types['uint8_t'];\n  if ('char-type' in conf && conf['char-type'] == 'int8') this.types['char'] = this.types['int8_t'];\n}\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\n\n\nCTypeParser.prototype.setEndian = function (endian) {\n  if (endian != 'big' && endian != 'little') throw new Error('invalid endian type, must be big or ' + 'little');\n  this.endian = endian;\n};\n/*\n * Returns the current value of the endian value for the parser.\n */\n\n\nCTypeParser.prototype.getEndian = function () {\n  return this.endian;\n};\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\n\n\nCTypeParser.prototype.typedef = function (name, value) {\n  var type;\n  if (name === undefined) throw new (Error('missing required typedef argument: name'))();\n  if (value === undefined) throw new (Error('missing required typedef argument: value'))();\n  if (typeof name != 'string') throw new (Error('the name of a type must be a string'))();\n  type = ctParseType(name);\n  if (type['len'] !== undefined) throw new Error('Cannot have an array in the typedef name');\n  if (name in this.types) throw new Error('typedef name already present: ' + name);\n  if (typeof value != 'string' && !(value instanceof Array)) throw new Error('typedef value must either be a string or ' + 'struct');\n\n  if (typeof value == 'string') {\n    type = ctParseType(value);\n\n    if (type['len'] !== undefined) {\n      if (isNaN(parseInt(type['len'], 10))) throw new (Error('typedef value must use ' + 'fixed size array when outside of a ' + 'struct'))();\n    }\n\n    this.types[name] = value;\n  } else {\n    /* We have a struct, validate it */\n    ctCheckReq(value, this.types);\n    this.types[name] = value;\n  }\n};\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\n\n\nCTypeParser.prototype.lstypes = function () {\n  var key;\n  var ret = {};\n\n  for (key in this.types) {\n    if (key in deftypes) continue;\n    ret[key] = this.types[key];\n  }\n\n  return ret;\n};\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\n\n\nfunction ctResolveArray(str, values) {\n  var ret = '';\n  var type = ctParseType(str);\n\n  while (type['len'] !== undefined) {\n    if (isNaN(parseInt(type['len'], 10))) {\n      if (typeof values[type['len']] != 'number') throw new Error('cannot sawp in non-number ' + 'for array value');\n      ret = '[' + values[type['len']] + ']' + ret;\n    } else {\n      ret = '[' + type['len'] + ']' + ret;\n    }\n\n    type = ctParseType(type['type']);\n  }\n\n  ret = type['type'] + ret;\n  return ret;\n}\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\n\n\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer, offset, value) {\n  var pt;\n  mod_assert.ok(type in this.types);\n\n  if (typeof this.types[type] == 'string') {\n    pt = ctParseType(this.types[type]);\n    if (dispatch == 'read') return this.readEntry(pt, buffer, offset);else if (dispatch == 'write') return this.writeEntry(value, pt, buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  } else {\n    if (dispatch == 'read') return this.readStruct(this.types[type], buffer, offset);else if (dispatch == 'write') return this.writeStruct(value, this.types[type], buffer, offset);else throw new Error('invalid dispatch type to ' + 'resolveTypedef');\n  }\n};\n/*\n * [private] Try and read in the specific entry.\n */\n\n\nCTypeParser.prototype.readEntry = function (type, buffer, offset) {\n  var parse, len;\n  /*\n   * Because we want to special case char[]s this is unfortunately\n   * a bit uglier than it really should be. We want to special\n   * case char[]s so that we return a node buffer, thus they are a\n   * first class type where as all other arrays just call into a\n   * generic array routine which calls their data-specific routine\n   * the specified number of times.\n   *\n   * The valid dispatch options we have are:\n   *  - Array and char => char[] handler\n   *  - Generic array handler\n   *  - Generic typedef handler\n   *  - Basic type handler\n   */\n\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') parse = this.types['char[]']['read'](len, this.endian, buffer, offset);else parse = this.readArray(type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) parse = this.types[type['type']]['read'](this.endian, buffer, offset);else parse = this.resolveTypedef(type['type'], 'read', buffer, offset);\n  }\n\n  return parse;\n};\n/*\n * [private] Read an array of data\n */\n\n\nCTypeParser.prototype.readArray = function (type, length, buffer, offset) {\n  var ii, ent, pt;\n  var baseOffset = offset;\n  var ret = new Array(length);\n  pt = ctParseType(type);\n\n  for (ii = 0; ii < length; ii++) {\n    ent = this.readEntry(pt, buffer, offset);\n    offset += ent['size'];\n    ret[ii] = ent['value'];\n  }\n\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n/*\n * [private] Read a single struct in.\n */\n\n\nCTypeParser.prototype.readStruct = function (def, buffer, offset) {\n  var parse, ii, type, entry, key;\n  var baseOffset = offset;\n  var ret = {};\n  /* Walk it and handle doing what's necessary */\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n    /* Resolve all array values */\n\n    type = ctParseType(ctResolveArray(entry['type'], ret));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    parse = this.readEntry(type, buffer, offset);\n    offset += parse['size'];\n    ret[key] = parse['value'];\n  }\n\n  return {\n    value: ret,\n    size: offset - baseOffset\n  };\n};\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\n\n\nCTypeParser.prototype.readData = function (def, buffer, offset) {\n  /* Sanity check for arguments */\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n  /* Sanity check the object definition */\n\n  ctCheckReq(def, this.types);\n  return this.readStruct(def, buffer, offset)['value'];\n};\n/*\n * [private] Write out an array of data\n */\n\n\nCTypeParser.prototype.writeArray = function (value, type, length, buffer, offset) {\n  var ii, pt;\n  var baseOffset = offset;\n  if (!(value instanceof Array)) throw new Error('asked to write an array, but value is not ' + 'an array');\n  if (value.length != length) throw new Error('asked to write array of length ' + length + ' but that does not match value length: ' + value.length);\n  pt = ctParseType(type);\n\n  for (ii = 0; ii < length; ii++) offset += this.writeEntry(value[ii], pt, buffer, offset);\n\n  return offset - baseOffset;\n};\n/*\n * [private] Write the specific entry\n */\n\n\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset) {\n  var len, ret;\n\n  if (type['len'] !== undefined) {\n    len = parseInt(type['len'], 10);\n    if (isNaN(len)) throw new Error('somehow got a non-numeric length');\n    if (type['type'] == 'char') ret = this.types['char[]']['write'](value, len, this.endian, buffer, offset);else ret = this.writeArray(value, type['type'], len, buffer, offset);\n  } else {\n    if (type['type'] in deftypes) ret = this.types[type['type']]['write'](value, this.endian, buffer, offset);else ret = this.resolveTypedef(type['type'], 'write', buffer, offset, value);\n  }\n\n  return ret;\n};\n/*\n * [private] Write a single struct out.\n */\n\n\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset) {\n  var ii, entry, type, key;\n  var baseOffset = offset;\n  var vals = {};\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    entry = def[ii][key];\n    type = ctParseType(ctResolveArray(entry['type'], vals));\n    if ('offset' in entry) offset = baseOffset + entry['offset'];\n    offset += this.writeEntry(value[ii], type, buffer, offset);\n    /* Now that we've written it out, we can use it for arrays */\n\n    vals[key] = value[ii];\n  }\n\n  return offset;\n};\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\n\n\nfunction getValues(def) {\n  var ii, out, key;\n  out = [];\n\n  for (ii = 0; ii < def.length; ii++) {\n    key = Object.keys(def[ii])[0];\n    mod_assert.ok('value' in def[ii][key]);\n    out.push(def[ii][key]['value']);\n  }\n\n  return out;\n}\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\n\n\nCTypeParser.prototype.writeData = function (def, buffer, offset, values) {\n  var hv;\n  if (def === undefined) throw new Error('missing definition for what we should be' + 'parsing');\n  if (buffer === undefined) throw new Error('missing buffer for what we should be ' + 'parsing');\n  if (offset === undefined) throw new Error('missing offset for what we should be ' + 'parsing');\n  hv = values != null && values != undefined;\n\n  if (hv) {\n    if (!Array.isArray(values)) throw new Error('missing values for writing');\n    ctCheckReq(def, this.types);\n  } else {\n    ctCheckReq(def, this.types, ['value']);\n  }\n\n  this.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\n\n\nfunction toAbs64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n  /* We have 20 bits worth of precision in this range */\n\n  if (val[0] >= 0x100000) throw new Error('value would become approximated');\n  return val[0] * Math.pow(2, 32) + val[1];\n}\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\n\n\nfunction toApprox64(val) {\n  if (val === undefined) throw new Error('missing required arg: value');\n  if (!Array.isArray(val)) throw new Error('value must be an array');\n  if (val.length != 2) throw new Error('value must be an array of length 2');\n  return Math.pow(2, 32) * val[0] + val[1];\n}\n\nfunction parseCTF(json, conf) {\n  var ctype = new CTypeParser(conf);\n  mod_ctf.ctfParseJson(json, ctype);\n  return ctype;\n}\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\n\n\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\nexports.parseCTF = parseCTF;\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;","map":{"version":3,"sources":["/home/hayaz/haya/haya/hosters.pk/node_modules/ctype/ctype.js"],"names":["mod_ctf","require","mod_ctio","mod_assert","deftypes","read","ctReadUint8","write","ctWriteUint8","ctReadUint16","ctWriteUint16","ctReadUint32","ctWriteUint32","ctReadUint64","ctWriteUint64","ctReadSint8","ctWriteSint8","ctReadSint16","ctWriteSint16","ctReadSint32","ctWriteSint32","ctReadSint64","ctWriteSint64","ctReadFloat","ctWriteFloat","ctReadDouble","ctWriteDouble","ctReadChar","ctWriteChar","ctReadCharArray","ctWriteCharArray","endian","buffer","offset","val","ruint8","value","size","ruint16","ruint32","ruint64","rsint8","rsint16","rsint32","rsint64","rfloat","rdouble","res","Buffer","length","ii","wuint8","wuint16","wuint32","wuint64","wsint8","wsint16","wsint32","wsint64","wfloat","wdouble","Error","ctGetBasicTypes","ret","key","ctParseType","str","begInd","endInd","type","len","lastIndexOf","substring","ctCheckReq","def","types","fields","jj","req","keys","found","Array","Object","undefined","isNaN","parseInt","CTypeParser","conf","prototype","setEndian","getEndian","typedef","name","lstypes","ctResolveArray","values","resolveTypedef","dispatch","pt","ok","readEntry","writeEntry","readStruct","writeStruct","parse","readArray","ent","baseOffset","entry","readData","writeArray","vals","getValues","out","push","writeData","hv","isArray","toAbs64","Math","pow","toApprox64","parseCTF","json","ctype","ctfParseJson","exports","Parser"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIE,UAAU,GAAGF,OAAO,CAAC,QAAD,CAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIG,QAAQ,GAAG;AACX,aAAY;AAAEC,IAAAA,IAAI,EAAEC,WAAR;AAAqBC,IAAAA,KAAK,EAAEC;AAA5B,GADD;AAEX,cAAY;AAAEH,IAAAA,IAAI,EAAEI,YAAR;AAAsBF,IAAAA,KAAK,EAAEG;AAA7B,GAFD;AAGX,cAAY;AAAEL,IAAAA,IAAI,EAAEM,YAAR;AAAsBJ,IAAAA,KAAK,EAAEK;AAA7B,GAHD;AAIX,cAAY;AAAEP,IAAAA,IAAI,EAAEQ,YAAR;AAAsBN,IAAAA,KAAK,EAAEO;AAA7B,GAJD;AAKX,YAAU;AAAET,IAAAA,IAAI,EAAEU,WAAR;AAAqBR,IAAAA,KAAK,EAAES;AAA5B,GALC;AAMX,aAAW;AAAEX,IAAAA,IAAI,EAAEY,YAAR;AAAsBV,IAAAA,KAAK,EAAEW;AAA7B,GANA;AAOX,aAAW;AAAEb,IAAAA,IAAI,EAAEc,YAAR;AAAsBZ,IAAAA,KAAK,EAAEa;AAA7B,GAPA;AAQX,aAAW;AAAEf,IAAAA,IAAI,EAAEgB,YAAR;AAAsBd,IAAAA,KAAK,EAAEe;AAA7B,GARA;AASX,WAAS;AAAEjB,IAAAA,IAAI,EAAEkB,WAAR;AAAqBhB,IAAAA,KAAK,EAAEiB;AAA5B,GATE;AAUX,YAAU;AAAEnB,IAAAA,IAAI,EAAEoB,YAAR;AAAsBlB,IAAAA,KAAK,EAAEmB;AAA7B,GAVC;AAWX,UAAQ;AAAErB,IAAAA,IAAI,EAAEsB,UAAR;AAAoBpB,IAAAA,KAAK,EAAEqB;AAA3B,GAXG;AAYX,YAAU;AAAEvB,IAAAA,IAAI,EAAEwB,eAAR;AAAyBtB,IAAAA,KAAK,EAAEuB;AAAhC;AAZC,CAAf;AAeA;AACA;AACA;AACA;;AACA,SAASxB,WAAT,CAAqByB,MAArB,EAA6BC,MAA7B,EAAqCC,MAArC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACiC,MAAT,CAAgBH,MAAhB,EAAwBD,MAAxB,EAAgCE,MAAhC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAAS5B,YAAT,CAAsBsB,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACoC,OAAT,CAAiBN,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAAS1B,YAAT,CAAsBoB,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACqC,OAAT,CAAiBP,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASxB,YAAT,CAAsBkB,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACsC,OAAT,CAAiBR,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAAStB,WAAT,CAAqBgB,MAArB,EAA6BC,MAA7B,EAAqCC,MAArC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACuC,MAAT,CAAgBT,MAAhB,EAAwBD,MAAxB,EAAgCE,MAAhC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASpB,YAAT,CAAsBc,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACwC,OAAT,CAAiBV,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASlB,YAAT,CAAsBY,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAACyC,OAAT,CAAiBX,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAAShB,YAAT,CAAsBU,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAAC0C,OAAT,CAAiBZ,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASd,WAAT,CAAqBQ,MAArB,EAA6BC,MAA7B,EAAqCC,MAArC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAAC2C,MAAT,CAAgBb,MAAhB,EAAwBD,MAAxB,EAAgCE,MAAhC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASZ,YAAT,CAAsBM,MAAtB,EAA8BC,MAA9B,EAAsCC,MAAtC,EACA;AACC,MAAIC,GAAG,GAAGhC,QAAQ,CAAC4C,OAAT,CAAiBd,MAAjB,EAAyBD,MAAzB,EAAiCE,MAAjC,CAAV;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEF,GAAT;AAAcG,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;AAED;AACA;AACA;;;AACA,SAASV,UAAT,CAAoBI,MAApB,EAA4BC,MAA5B,EAAoCC,MAApC,EACA;AACC,MAAIc,GAAG,GAAG,IAAIC,MAAJ,CAAW,CAAX,CAAV;AACAD,EAAAA,GAAG,CAAC,CAAD,CAAH,GAAS7C,QAAQ,CAACiC,MAAT,CAAgBH,MAAhB,EAAwBD,MAAxB,EAAgCE,MAAhC,CAAT;AACA,SAAQ;AAAEG,IAAAA,KAAK,EAAEW,GAAT;AAAcV,IAAAA,IAAI,EAAE;AAApB,GAAR;AACA;;AAED,SAASR,eAAT,CAAyBoB,MAAzB,EAAiClB,MAAjC,EAAyCC,MAAzC,EAAiDC,MAAjD,EACA;AACC,MAAIiB,EAAJ;AACA,MAAIH,GAAG,GAAG,IAAIC,MAAJ,CAAWC,MAAX,CAAV;;AAEA,OAAKC,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGD,MAAlB,EAA0BC,EAAE,EAA5B,EACCH,GAAG,CAACG,EAAD,CAAH,GAAUhD,QAAQ,CAACiC,MAAT,CAAgBH,MAAhB,EAAwBD,MAAxB,EAAgCE,MAAM,GAAGiB,EAAzC,CAAV;;AAED,SAAQ;AAAEd,IAAAA,KAAK,EAAEW,GAAT;AAAcV,IAAAA,IAAI,EAAEY;AAApB,GAAR;AACA;;AAED,SAASzC,YAAT,CAAsB4B,KAAtB,EAA6BL,MAA7B,EAAqCC,MAArC,EAA6CC,MAA7C,EACA;AACC/B,EAAAA,QAAQ,CAACiD,MAAT,CAAgBf,KAAhB,EAAuBL,MAAvB,EAA+BC,MAA/B,EAAuCC,MAAvC;AACA,SAAQ,CAAR;AACA;;AAED,SAASvB,aAAT,CAAuB0B,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACkD,OAAT,CAAiBhB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAASrB,aAAT,CAAuBwB,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACmD,OAAT,CAAiBjB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAASnB,aAAT,CAAuBsB,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACoD,OAAT,CAAiBlB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAASjB,YAAT,CAAsBoB,KAAtB,EAA6BL,MAA7B,EAAqCC,MAArC,EAA6CC,MAA7C,EACA;AACC/B,EAAAA,QAAQ,CAACqD,MAAT,CAAgBnB,KAAhB,EAAuBL,MAAvB,EAA+BC,MAA/B,EAAuCC,MAAvC;AACA,SAAQ,CAAR;AACA;;AAED,SAASf,aAAT,CAAuBkB,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACsD,OAAT,CAAiBpB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAASb,aAAT,CAAuBgB,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACuD,OAAT,CAAiBrB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAASX,aAAT,CAAuBc,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAACwD,OAAT,CAAiBtB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;;AAED,SAAST,YAAT,CAAsBY,KAAtB,EAA6BL,MAA7B,EAAqCC,MAArC,EAA6CC,MAA7C,EACA;AACC/B,EAAAA,QAAQ,CAACyD,MAAT,CAAgBvB,KAAhB,EAAuBL,MAAvB,EAA+BC,MAA/B,EAAuCC,MAAvC;AACA,SAAQ,CAAR;AACA;;AAED,SAASP,aAAT,CAAuBU,KAAvB,EAA8BL,MAA9B,EAAsCC,MAAtC,EAA8CC,MAA9C,EACA;AACC/B,EAAAA,QAAQ,CAAC0D,OAAT,CAAiBxB,KAAjB,EAAwBL,MAAxB,EAAgCC,MAAhC,EAAwCC,MAAxC;AACA,SAAQ,CAAR;AACA;AAED;AACA;AACA;;;AACA,SAASL,WAAT,CAAqBQ,KAArB,EAA4BL,MAA5B,EAAoCC,MAApC,EAA4CC,MAA5C,EACA;AACC,MAAI,EAAEG,KAAK,YAAYY,MAAnB,CAAJ,EACC,MAAO,IAAIa,KAAJ,CAAU,wBAAV,CAAP;AAED3D,EAAAA,QAAQ,CAACiC,MAAT,CAAgBC,KAAK,CAAC,CAAD,CAArB,EAA0BL,MAA1B,EAAkCC,MAAlC,EAA0CC,MAA1C;AACA,SAAQ,CAAR;AACA;AAED;AACA;AACA;AACA;;;AACA,SAASH,gBAAT,CAA0BM,KAA1B,EAAiCa,MAAjC,EAAyClB,MAAzC,EAAiDC,MAAjD,EAAyDC,MAAzD,EACA;AACC,MAAIiB,EAAJ;AAEA,MAAI,EAAEd,KAAK,YAAYY,MAAnB,CAAJ,EACC,MAAO,IAAIa,KAAJ,CAAU,wBAAV,CAAP;AAED,MAAIzB,KAAK,CAACa,MAAN,GAAeA,MAAnB,EACC,MAAO,IAAIY,KAAJ,CAAU,wCAAV,CAAP;;AAED,OAAKX,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGd,KAAK,CAACa,MAAX,IAAqBC,EAAE,GAAGD,MAAvC,EAA+CC,EAAE,EAAjD,EACChD,QAAQ,CAACiD,MAAT,CAAgBf,KAAK,CAACc,EAAD,CAArB,EAA2BnB,MAA3B,EAAmCC,MAAnC,EAA2CC,MAAM,GAAGiB,EAApD;;AAED,SAAOA,EAAE,GAAGD,MAAZ,EAAoBC,EAAE,EAAtB,EACChD,QAAQ,CAACiD,MAAT,CAAgB,CAAhB,EAAmBpB,MAAnB,EAA2BE,MAAM,GAAGiB,EAApC;;AAGD,SAAQD,MAAR;AACA;AAED;AACA;AACA;AACA;;;AACA,SAASa,eAAT,GACA;AACC,MAAIC,GAAG,GAAG,EAAV;AACA,MAAIC,GAAJ;;AACA,OAAKA,GAAL,IAAY5D,QAAZ,EACC2D,GAAG,CAACC,GAAD,CAAH,GAAW5D,QAAQ,CAAC4D,GAAD,CAAnB;;AAED,SAAQD,GAAR;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,WAAT,CAAqBC,GAArB,EACA;AACC,MAAIC,MAAJ,EAAYC,MAAZ;AACA,MAAIC,IAAJ,EAAUC,GAAV;AACA,MAAI,OAAQJ,GAAR,IAAgB,QAApB,EACC,MAAO,IAAIL,KAAJ,CAAU,kCAAV,CAAP;AAEDO,EAAAA,MAAM,GAAGF,GAAG,CAACK,WAAJ,CAAgB,GAAhB,CAAT;;AACA,MAAIH,MAAM,IAAI,CAAC,CAAf,EAAkB;AACjB,QAAIF,GAAG,CAACK,WAAJ,CAAgB,GAAhB,KAAwB,CAAC,CAA7B,EACC,MAAO,IAAIV,KAAJ,CAAU,uCACb,wBADG,CAAP;AAGD,WAAQ;AAAEQ,MAAAA,IAAI,EAAEH;AAAR,KAAR;AACA;;AAEDC,EAAAA,MAAM,GAAGD,GAAG,CAACK,WAAJ,CAAgB,GAAhB,CAAT;AACA,MAAIJ,MAAM,IAAI,CAAC,CAAf,EACC,MAAO,IAAIN,KAAJ,CAAU,uCACb,wBADG,CAAP;AAGD,MAAIM,MAAM,IAAIC,MAAd,EACC,MAAO,IAAIP,KAAJ,CAAU,4CAAV,CAAP;AAEDQ,EAAAA,IAAI,GAAGH,GAAG,CAACM,SAAJ,CAAc,CAAd,EAAiBL,MAAjB,CAAP;AACAG,EAAAA,GAAG,GAAGJ,GAAG,CAACM,SAAJ,CAAcL,MAAM,GAAG,CAAvB,EAA0BC,MAA1B,CAAN;AAEA,SAAQ;AAAEC,IAAAA,IAAI,EAAEA,IAAR;AAAcC,IAAAA,GAAG,EAAEA;AAAnB,GAAR;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,UAAT,CAAoBC,GAApB,EAAyBC,KAAzB,EAAgCC,MAAhC,EACA;AACC,MAAI1B,EAAJ,EAAQ2B,EAAR;AACA,MAAIC,GAAJ,EAASC,IAAT,EAAef,GAAf;AACA,MAAIgB,KAAK,GAAG,EAAZ;AAEA,MAAI,EAAEN,GAAG,YAAYO,KAAjB,CAAJ,EACC,MAAO,IAAIpB,KAAJ,CAAU,4BAAV,CAAP;AAED,MAAIa,GAAG,CAACzB,MAAJ,KAAe,CAAnB,EACC,MAAO,IAAIY,KAAJ,CAAU,2CAAV,CAAP;;AAED,OAAKX,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGwB,GAAG,CAACzB,MAAtB,EAA8BC,EAAE,EAAhC,EAAoC;AACnC4B,IAAAA,GAAG,GAAGJ,GAAG,CAACxB,EAAD,CAAT;AACA,QAAI,EAAE4B,GAAG,YAAYI,MAAjB,CAAJ,EACC,MAAO,IAAIrB,KAAJ,CAAU,mCACb,SADG,CAAP;AAGDkB,IAAAA,IAAI,GAAGG,MAAM,CAACH,IAAP,CAAYD,GAAZ,CAAP;AACA,QAAIC,IAAI,CAAC9B,MAAL,IAAe,CAAnB,EACC,MAAO,IAAIY,KAAJ,CAAU,qCACb,SADG,CAAP;AAGD,QAAIkB,IAAI,CAAC,CAAD,CAAJ,IAAWC,KAAf,EACC,MAAO,IAAInB,KAAJ,CAAU,4BACb,aADa,GACGkB,IAAI,CAAC,CAAD,CADjB,CAAP;AAGD,QAAI,EAAE,UAAUD,GAAG,CAACC,IAAI,CAAC,CAAD,CAAL,CAAf,CAAJ,EACC,MAAO,IAAIlB,KAAJ,CAAU,kCAAV,CAAP;AAEDG,IAAAA,GAAG,GAAGC,WAAW,CAACa,GAAG,CAACC,IAAI,CAAC,CAAD,CAAL,CAAH,CAAa,MAAb,CAAD,CAAjB;AAEA;AACF;AACA;AACA;AACA;AACA;;AACE,WAAOf,GAAG,CAAC,KAAD,CAAH,KAAemB,SAAtB,EAAiC;AAChC,UAAIC,KAAK,CAACC,QAAQ,CAACrB,GAAG,CAAC,KAAD,CAAJ,EAAa,EAAb,CAAT,CAAT,EAAqC;AACpC,YAAI,EAAEA,GAAG,CAAC,KAAD,CAAH,IAAcgB,KAAhB,CAAJ,EACC,MAAO,IAAInB,KAAJ,CAAU,oBACb,gCADG,CAAP;AAGD;;AAEDG,MAAAA,GAAG,GAAGC,WAAW,CAACD,GAAG,CAAC,MAAD,CAAJ,CAAjB;AACA;AAED;;;AACA,QAAI,EAAEA,GAAG,CAAC,MAAD,CAAH,IAAeW,KAAjB,CAAJ,EACC,MAAO,IAAId,KAAJ,CAAU,iCACbG,GAAG,CAAC,MAAD,CADA,CAAP;AAGD;;AACA,QAAIY,MAAM,KAAKO,SAAf,EAA0B;AACzB,WAAKN,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGD,MAAM,CAAC3B,MAAzB,EAAiC4B,EAAE,EAAnC,EAAuC;AACtC,YAAI,EAAED,MAAM,CAACC,EAAD,CAAN,IAAcC,GAAG,CAACC,IAAI,CAAC,CAAD,CAAL,CAAnB,CAAJ,EACC,MAAO,IAAIlB,KAAJ,CAAU,sBACb,SADa,GACDe,MAAM,CAACC,EAAD,CADf,CAAP;AAED;AACD;;AAEDG,IAAAA,KAAK,CAACD,IAAI,CAAC,CAAD,CAAL,CAAL,GAAiB,IAAjB;AACA;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,WAAT,CAAqBC,IAArB,EACA;AACC,MAAI,CAACA,IAAL,EAAW,MAAO,IAAI1B,KAAJ,CAAU,2BAAV,CAAP;AAEX,MAAI,EAAE,YAAY0B,IAAd,CAAJ,EACC,MAAO,IAAI1B,KAAJ,CAAU,+BAAV,CAAP;AAED,MAAI0B,IAAI,CAAC,QAAD,CAAJ,IAAkB,KAAlB,IAA2BA,IAAI,CAAC,QAAD,CAAJ,IAAkB,QAAjD,EACC,MAAO,IAAI1B,KAAJ,CAAU,qBAAV,CAAP;AAED,MAAI,eAAe0B,IAAf,IAAwBA,IAAI,CAAC,WAAD,CAAJ,IAAqB,OAArB,IACxBA,IAAI,CAAC,WAAD,CAAJ,IAAqB,MADzB,EAEC,MAAO,IAAI1B,KAAJ,CAAU,mCACb0B,IAAI,CAAC,WAAD,CADD,CAAP;AAGD,OAAKxD,MAAL,GAAcwD,IAAI,CAAC,QAAD,CAAlB;AACA,OAAKZ,KAAL,GAAab,eAAe,EAA5B;AAEA;AACD;AACA;AACA;;AACC,MAAI,eAAeyB,IAAf,IAAuBA,IAAI,CAAC,WAAD,CAAJ,IAAqB,OAAhD,EACC,KAAKZ,KAAL,CAAW,MAAX,IAAqB,KAAKA,KAAL,CAAW,SAAX,CAArB;AAED,MAAI,eAAeY,IAAf,IAAuBA,IAAI,CAAC,WAAD,CAAJ,IAAqB,MAAhD,EACC,KAAKZ,KAAL,CAAW,MAAX,IAAqB,KAAKA,KAAL,CAAW,QAAX,CAArB;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAW,WAAW,CAACE,SAAZ,CAAsBC,SAAtB,GAAkC,UAAU1D,MAAV,EAClC;AACC,MAAIA,MAAM,IAAI,KAAV,IAAmBA,MAAM,IAAI,QAAjC,EACC,MAAO,IAAI8B,KAAJ,CAAU,yCACb,QADG,CAAP;AAGD,OAAK9B,MAAL,GAAcA,MAAd;AACA,CAPD;AASA;AACA;AACA;;;AACAuD,WAAW,CAACE,SAAZ,CAAsBE,SAAtB,GAAkC,YAClC;AACC,SAAQ,KAAK3D,MAAb;AACA,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAuD,WAAW,CAACE,SAAZ,CAAsBG,OAAtB,GAAgC,UAAUC,IAAV,EAAgBxD,KAAhB,EAChC;AACC,MAAIiC,IAAJ;AAEA,MAAIuB,IAAI,KAAKT,SAAb,EACC,MAAO,KAAKtB,KAAK,CAAC,yCAAD,CAAV,GAAP;AAED,MAAIzB,KAAK,KAAK+C,SAAd,EACC,MAAO,KAAKtB,KAAK,CAAC,0CAAD,CAAV,GAAP;AAED,MAAI,OAAQ+B,IAAR,IAAiB,QAArB,EACC,MAAO,KAAK/B,KAAK,CAAC,qCAAD,CAAV,GAAP;AAEDQ,EAAAA,IAAI,GAAGJ,WAAW,CAAC2B,IAAD,CAAlB;AAEA,MAAIvB,IAAI,CAAC,KAAD,CAAJ,KAAgBc,SAApB,EACC,MAAO,IAAItB,KAAJ,CAAU,0CAAV,CAAP;AAED,MAAI+B,IAAI,IAAI,KAAKjB,KAAjB,EACC,MAAO,IAAId,KAAJ,CAAU,mCAAmC+B,IAA7C,CAAP;AAED,MAAI,OAAQxD,KAAR,IAAkB,QAAlB,IAA8B,EAAEA,KAAK,YAAY6C,KAAnB,CAAlC,EACC,MAAO,IAAIpB,KAAJ,CAAU,8CACb,QADG,CAAP;;AAGD,MAAI,OAAQzB,KAAR,IAAkB,QAAtB,EAAgC;AAC/BiC,IAAAA,IAAI,GAAGJ,WAAW,CAAC7B,KAAD,CAAlB;;AACA,QAAIiC,IAAI,CAAC,KAAD,CAAJ,KAAgBc,SAApB,EAA+B;AAC9B,UAAIC,KAAK,CAACC,QAAQ,CAAChB,IAAI,CAAC,KAAD,CAAL,EAAc,EAAd,CAAT,CAAT,EACC,MAAO,KAAKR,KAAK,CAAC,4BACd,qCADc,GAEd,QAFa,CAAV,GAAP;AAGD;;AAED,SAAKc,KAAL,CAAWiB,IAAX,IAAmBxD,KAAnB;AACA,GAVD,MAUO;AACN;AACAqC,IAAAA,UAAU,CAACrC,KAAD,EAAQ,KAAKuC,KAAb,CAAV;AACA,SAAKA,KAAL,CAAWiB,IAAX,IAAmBxD,KAAnB;AACA;AACD,CAxCD;AA0CA;AACA;AACA;AACA;;;AACAkD,WAAW,CAACE,SAAZ,CAAsBK,OAAtB,GAAgC,YAChC;AACC,MAAI7B,GAAJ;AACA,MAAID,GAAG,GAAG,EAAV;;AAEA,OAAKC,GAAL,IAAY,KAAKW,KAAjB,EAAwB;AACvB,QAAIX,GAAG,IAAI5D,QAAX,EACC;AACD2D,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,KAAKW,KAAL,CAAWX,GAAX,CAAX;AACA;;AAED,SAAQD,GAAR;AACA,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+B,cAAT,CAAwB5B,GAAxB,EAA6B6B,MAA7B,EACA;AACC,MAAIhC,GAAG,GAAG,EAAV;AACA,MAAIM,IAAI,GAAGJ,WAAW,CAACC,GAAD,CAAtB;;AAEA,SAAOG,IAAI,CAAC,KAAD,CAAJ,KAAgBc,SAAvB,EAAkC;AACjC,QAAIC,KAAK,CAACC,QAAQ,CAAChB,IAAI,CAAC,KAAD,CAAL,EAAc,EAAd,CAAT,CAAT,EAAsC;AACrC,UAAI,OAAQ0B,MAAM,CAAC1B,IAAI,CAAC,KAAD,CAAL,CAAd,IAAgC,QAApC,EACC,MAAO,IAAIR,KAAJ,CAAU,+BACb,iBADG,CAAP;AAEDE,MAAAA,GAAG,GAAG,MAAMgC,MAAM,CAAC1B,IAAI,CAAC,KAAD,CAAL,CAAZ,GAA4B,GAA5B,GAAkCN,GAAxC;AACA,KALD,MAKO;AACNA,MAAAA,GAAG,GAAG,MAAMM,IAAI,CAAC,KAAD,CAAV,GAAoB,GAApB,GAA0BN,GAAhC;AACA;;AACDM,IAAAA,IAAI,GAAGJ,WAAW,CAACI,IAAI,CAAC,MAAD,CAAL,CAAlB;AACA;;AAEDN,EAAAA,GAAG,GAAGM,IAAI,CAAC,MAAD,CAAJ,GAAeN,GAArB;AAEA,SAAQA,GAAR;AACA;AAED;AACA;AACA;AACA;AACA;;;AACAuB,WAAW,CAACE,SAAZ,CAAsBQ,cAAtB,GAAuC,UAAU3B,IAAV,EAAgB4B,QAAhB,EAA0BjE,MAA1B,EACnCC,MADmC,EAC3BG,KAD2B,EAEvC;AACC,MAAI8D,EAAJ;AAEA/F,EAAAA,UAAU,CAACgG,EAAX,CAAc9B,IAAI,IAAI,KAAKM,KAA3B;;AACA,MAAI,OAAQ,KAAKA,KAAL,CAAWN,IAAX,CAAR,IAA6B,QAAjC,EAA2C;AAC1C6B,IAAAA,EAAE,GAAGjC,WAAW,CAAC,KAAKU,KAAL,CAAWN,IAAX,CAAD,CAAhB;AACA,QAAI4B,QAAQ,IAAI,MAAhB,EACC,OAAQ,KAAKG,SAAL,CAAeF,EAAf,EAAmBlE,MAAnB,EAA2BC,MAA3B,CAAR,CADD,KAEK,IAAIgE,QAAQ,IAAI,OAAhB,EACJ,OAAQ,KAAKI,UAAL,CAAgBjE,KAAhB,EAAuB8D,EAAvB,EAA2BlE,MAA3B,EAAmCC,MAAnC,CAAR,CADI,KAGJ,MAAO,IAAI4B,KAAJ,CAAU,8BACb,gBADG,CAAP;AAED,GATD,MASO;AACN,QAAIoC,QAAQ,IAAI,MAAhB,EACC,OAAQ,KAAKK,UAAL,CAAgB,KAAK3B,KAAL,CAAWN,IAAX,CAAhB,EAAkCrC,MAAlC,EACJC,MADI,CAAR,CADD,KAGK,IAAIgE,QAAQ,IAAI,OAAhB,EACJ,OAAQ,KAAKM,WAAL,CAAiBnE,KAAjB,EAAwB,KAAKuC,KAAL,CAAWN,IAAX,CAAxB,EACJrC,MADI,EACIC,MADJ,CAAR,CADI,KAIJ,MAAO,IAAI4B,KAAJ,CAAU,8BACb,gBADG,CAAP;AAED;AAED,CA3BD;AA6BA;AACA;AACA;;;AACAyB,WAAW,CAACE,SAAZ,CAAsBY,SAAtB,GAAkC,UAAU/B,IAAV,EAAgBrC,MAAhB,EAAwBC,MAAxB,EAClC;AACC,MAAIuE,KAAJ,EAAWlC,GAAX;AAEA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACC,MAAID,IAAI,CAAC,KAAD,CAAJ,KAAgBc,SAApB,EAA+B;AAC9Bb,IAAAA,GAAG,GAAGe,QAAQ,CAAChB,IAAI,CAAC,KAAD,CAAL,EAAc,EAAd,CAAd;AACA,QAAIe,KAAK,CAACd,GAAD,CAAT,EACC,MAAO,IAAIT,KAAJ,CAAU,kCAAV,CAAP;AAED,QAAIQ,IAAI,CAAC,MAAD,CAAJ,IAAgB,MAApB,EACCmC,KAAK,GAAG,KAAK7B,KAAL,CAAW,QAAX,EAAqB,MAArB,EAA6BL,GAA7B,EACJ,KAAKvC,MADD,EACSC,MADT,EACiBC,MADjB,CAAR,CADD,KAICuE,KAAK,GAAG,KAAKC,SAAL,CAAepC,IAAI,CAAC,MAAD,CAAnB,EACJC,GADI,EACCtC,MADD,EACSC,MADT,CAAR;AAED,GAXD,MAWO;AACN,QAAIoC,IAAI,CAAC,MAAD,CAAJ,IAAgBjE,QAApB,EACCoG,KAAK,GAAG,KAAK7B,KAAL,CAAWN,IAAI,CAAC,MAAD,CAAf,EAAyB,MAAzB,EAAiC,KAAKtC,MAAtC,EACJC,MADI,EACIC,MADJ,CAAR,CADD,KAICuE,KAAK,GAAG,KAAKR,cAAL,CAAoB3B,IAAI,CAAC,MAAD,CAAxB,EAAkC,MAAlC,EACJrC,MADI,EACIC,MADJ,CAAR;AAED;;AAED,SAAQuE,KAAR;AACA,CAvCD;AAyCA;AACA;AACA;;;AACAlB,WAAW,CAACE,SAAZ,CAAsBiB,SAAtB,GAAkC,UAAUpC,IAAV,EAAgBpB,MAAhB,EAAwBjB,MAAxB,EAAgCC,MAAhC,EAClC;AACC,MAAIiB,EAAJ,EAAQwD,GAAR,EAAaR,EAAb;AACA,MAAIS,UAAU,GAAG1E,MAAjB;AACA,MAAI8B,GAAG,GAAG,IAAIkB,KAAJ,CAAUhC,MAAV,CAAV;AACAiD,EAAAA,EAAE,GAAGjC,WAAW,CAACI,IAAD,CAAhB;;AAEA,OAAKnB,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGD,MAAlB,EAA0BC,EAAE,EAA5B,EAAgC;AAC/BwD,IAAAA,GAAG,GAAG,KAAKN,SAAL,CAAeF,EAAf,EAAmBlE,MAAnB,EAA2BC,MAA3B,CAAN;AACAA,IAAAA,MAAM,IAAIyE,GAAG,CAAC,MAAD,CAAb;AACA3C,IAAAA,GAAG,CAACb,EAAD,CAAH,GAAUwD,GAAG,CAAC,OAAD,CAAb;AACA;;AAED,SAAQ;AAAEtE,IAAAA,KAAK,EAAE2B,GAAT;AAAc1B,IAAAA,IAAI,EAAEJ,MAAM,GAAG0E;AAA7B,GAAR;AACA,CAdD;AAgBA;AACA;AACA;;;AACArB,WAAW,CAACE,SAAZ,CAAsBc,UAAtB,GAAmC,UAAU5B,GAAV,EAAe1C,MAAf,EAAuBC,MAAvB,EACnC;AACC,MAAIuE,KAAJ,EAAWtD,EAAX,EAAemB,IAAf,EAAqBuC,KAArB,EAA4B5C,GAA5B;AACA,MAAI2C,UAAU,GAAG1E,MAAjB;AACA,MAAI8B,GAAG,GAAG,EAAV;AAEA;;AACA,OAAKb,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGwB,GAAG,CAACzB,MAAtB,EAA8BC,EAAE,EAAhC,EAAoC;AACnCc,IAAAA,GAAG,GAAGkB,MAAM,CAACH,IAAP,CAAYL,GAAG,CAACxB,EAAD,CAAf,EAAqB,CAArB,CAAN;AACA0D,IAAAA,KAAK,GAAGlC,GAAG,CAACxB,EAAD,CAAH,CAAQc,GAAR,CAAR;AAEA;;AACAK,IAAAA,IAAI,GAAGJ,WAAW,CAAC6B,cAAc,CAACc,KAAK,CAAC,MAAD,CAAN,EAAgB7C,GAAhB,CAAf,CAAlB;AAEA,QAAI,YAAY6C,KAAhB,EACC3E,MAAM,GAAG0E,UAAU,GAAGC,KAAK,CAAC,QAAD,CAA3B;AAEDJ,IAAAA,KAAK,GAAG,KAAKJ,SAAL,CAAe/B,IAAf,EAAqBrC,MAArB,EAA6BC,MAA7B,CAAR;AAEAA,IAAAA,MAAM,IAAIuE,KAAK,CAAC,MAAD,CAAf;AACAzC,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWwC,KAAK,CAAC,OAAD,CAAhB;AACA;;AAED,SAAQ;AAAEpE,IAAAA,KAAK,EAAE2B,GAAT;AAAc1B,IAAAA,IAAI,EAAGJ,MAAM,GAAC0E;AAA5B,GAAR;AACA,CAxBD;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACArB,WAAW,CAACE,SAAZ,CAAsBqB,QAAtB,GAAiC,UAAUnC,GAAV,EAAe1C,MAAf,EAAuBC,MAAvB,EACjC;AACC;AACA,MAAIyC,GAAG,KAAKS,SAAZ,EACC,MAAO,IAAItB,KAAJ,CAAU,6CACb,SADG,CAAP;AAGD,MAAI7B,MAAM,KAAKmD,SAAf,EACC,MAAO,IAAItB,KAAJ,CAAU,0CACb,SADG,CAAP;AAGD,MAAI5B,MAAM,KAAKkD,SAAf,EACC,MAAO,IAAItB,KAAJ,CAAU,0CACb,SADG,CAAP;AAGD;;AACAY,EAAAA,UAAU,CAACC,GAAD,EAAM,KAAKC,KAAX,CAAV;AAEA,SAAQ,KAAK2B,UAAL,CAAgB5B,GAAhB,EAAqB1C,MAArB,EAA6BC,MAA7B,EAAqC,OAArC,CAAR;AACA,CAnBD;AAqBA;AACA;AACA;;;AACAqD,WAAW,CAACE,SAAZ,CAAsBsB,UAAtB,GAAmC,UAAU1E,KAAV,EAAiBiC,IAAjB,EAAuBpB,MAAvB,EAA+BjB,MAA/B,EAC/BC,MAD+B,EAEnC;AACC,MAAIiB,EAAJ,EAAQgD,EAAR;AACA,MAAIS,UAAU,GAAG1E,MAAjB;AACA,MAAI,EAAEG,KAAK,YAAY6C,KAAnB,CAAJ,EACC,MAAO,IAAIpB,KAAJ,CAAU,+CACb,UADG,CAAP;AAGD,MAAIzB,KAAK,CAACa,MAAN,IAAgBA,MAApB,EACC,MAAO,IAAIY,KAAJ,CAAU,oCAAoCZ,MAApC,GACb,yCADa,GAC+Bb,KAAK,CAACa,MAD/C,CAAP;AAGDiD,EAAAA,EAAE,GAAGjC,WAAW,CAACI,IAAD,CAAhB;;AACA,OAAKnB,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGD,MAAlB,EAA0BC,EAAE,EAA5B,EACCjB,MAAM,IAAI,KAAKoE,UAAL,CAAgBjE,KAAK,CAACc,EAAD,CAArB,EAA2BgD,EAA3B,EAA+BlE,MAA/B,EAAuCC,MAAvC,CAAV;;AAED,SAAQA,MAAM,GAAG0E,UAAjB;AACA,CAlBD;AAoBA;AACA;AACA;;;AACArB,WAAW,CAACE,SAAZ,CAAsBa,UAAtB,GAAmC,UAAUjE,KAAV,EAAiBiC,IAAjB,EAAuBrC,MAAvB,EAA+BC,MAA/B,EACnC;AACC,MAAIqC,GAAJ,EAASP,GAAT;;AAEA,MAAIM,IAAI,CAAC,KAAD,CAAJ,KAAgBc,SAApB,EAA+B;AAC9Bb,IAAAA,GAAG,GAAGe,QAAQ,CAAChB,IAAI,CAAC,KAAD,CAAL,EAAc,EAAd,CAAd;AACA,QAAIe,KAAK,CAACd,GAAD,CAAT,EACC,MAAO,IAAIT,KAAJ,CAAU,kCAAV,CAAP;AAED,QAAIQ,IAAI,CAAC,MAAD,CAAJ,IAAgB,MAApB,EACCN,GAAG,GAAG,KAAKY,KAAL,CAAW,QAAX,EAAqB,OAArB,EAA8BvC,KAA9B,EAAqCkC,GAArC,EACF,KAAKvC,MADH,EACWC,MADX,EACmBC,MADnB,CAAN,CADD,KAIC8B,GAAG,GAAG,KAAK+C,UAAL,CAAgB1E,KAAhB,EAAuBiC,IAAI,CAAC,MAAD,CAA3B,EACFC,GADE,EACGtC,MADH,EACWC,MADX,CAAN;AAED,GAXD,MAWO;AACN,QAAIoC,IAAI,CAAC,MAAD,CAAJ,IAAgBjE,QAApB,EACC2D,GAAG,GAAG,KAAKY,KAAL,CAAWN,IAAI,CAAC,MAAD,CAAf,EAAyB,OAAzB,EAAkCjC,KAAlC,EACF,KAAKL,MADH,EACWC,MADX,EACmBC,MADnB,CAAN,CADD,KAIC8B,GAAG,GAAG,KAAKiC,cAAL,CAAoB3B,IAAI,CAAC,MAAD,CAAxB,EAAkC,OAAlC,EACFrC,MADE,EACMC,MADN,EACcG,KADd,CAAN;AAED;;AAED,SAAQ2B,GAAR;AACA,CAzBD;AA2BA;AACA;AACA;;;AACAuB,WAAW,CAACE,SAAZ,CAAsBe,WAAtB,GAAoC,UAAUnE,KAAV,EAAiBsC,GAAjB,EAAsB1C,MAAtB,EAA8BC,MAA9B,EACpC;AACC,MAAIiB,EAAJ,EAAQ0D,KAAR,EAAevC,IAAf,EAAqBL,GAArB;AACA,MAAI2C,UAAU,GAAG1E,MAAjB;AACA,MAAI8E,IAAI,GAAG,EAAX;;AAEA,OAAK7D,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGwB,GAAG,CAACzB,MAAtB,EAA8BC,EAAE,EAAhC,EAAoC;AACnCc,IAAAA,GAAG,GAAGkB,MAAM,CAACH,IAAP,CAAYL,GAAG,CAACxB,EAAD,CAAf,EAAqB,CAArB,CAAN;AACA0D,IAAAA,KAAK,GAAGlC,GAAG,CAACxB,EAAD,CAAH,CAAQc,GAAR,CAAR;AAEAK,IAAAA,IAAI,GAAGJ,WAAW,CAAC6B,cAAc,CAACc,KAAK,CAAC,MAAD,CAAN,EAAgBG,IAAhB,CAAf,CAAlB;AAEA,QAAI,YAAYH,KAAhB,EACC3E,MAAM,GAAG0E,UAAU,GAAGC,KAAK,CAAC,QAAD,CAA3B;AAED3E,IAAAA,MAAM,IAAI,KAAKoE,UAAL,CAAgBjE,KAAK,CAACc,EAAD,CAArB,EAA2BmB,IAA3B,EAAiCrC,MAAjC,EAAyCC,MAAzC,CAAV;AACA;;AACA8E,IAAAA,IAAI,CAAC/C,GAAD,CAAJ,GAAY5B,KAAK,CAACc,EAAD,CAAjB;AACA;;AAED,SAAQjB,MAAR;AACA,CArBD;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS+E,SAAT,CAAmBtC,GAAnB,EACA;AACC,MAAIxB,EAAJ,EAAQ+D,GAAR,EAAajD,GAAb;AACAiD,EAAAA,GAAG,GAAG,EAAN;;AACA,OAAK/D,EAAE,GAAG,CAAV,EAAaA,EAAE,GAAGwB,GAAG,CAACzB,MAAtB,EAA8BC,EAAE,EAAhC,EAAoC;AACnCc,IAAAA,GAAG,GAAGkB,MAAM,CAACH,IAAP,CAAYL,GAAG,CAACxB,EAAD,CAAf,EAAqB,CAArB,CAAN;AACA/C,IAAAA,UAAU,CAACgG,EAAX,CAAc,WAAWzB,GAAG,CAACxB,EAAD,CAAH,CAAQc,GAAR,CAAzB;AACAiD,IAAAA,GAAG,CAACC,IAAJ,CAASxC,GAAG,CAACxB,EAAD,CAAH,CAAQc,GAAR,EAAa,OAAb,CAAT;AACA;;AAED,SAAQiD,GAAR;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3B,WAAW,CAACE,SAAZ,CAAsB2B,SAAtB,GAAkC,UAAUzC,GAAV,EAAe1C,MAAf,EAAuBC,MAAvB,EAA+B8D,MAA/B,EAClC;AACC,MAAIqB,EAAJ;AAEA,MAAI1C,GAAG,KAAKS,SAAZ,EACC,MAAO,IAAItB,KAAJ,CAAU,6CACb,SADG,CAAP;AAGD,MAAI7B,MAAM,KAAKmD,SAAf,EACC,MAAO,IAAItB,KAAJ,CAAU,0CACb,SADG,CAAP;AAGD,MAAI5B,MAAM,KAAKkD,SAAf,EACC,MAAO,IAAItB,KAAJ,CAAU,0CACb,SADG,CAAP;AAGDuD,EAAAA,EAAE,GAAIrB,MAAM,IAAI,IAAV,IAAkBA,MAAM,IAAIZ,SAAlC;;AACA,MAAIiC,EAAJ,EAAQ;AACP,QAAI,CAACnC,KAAK,CAACoC,OAAN,CAActB,MAAd,CAAL,EACC,MAAO,IAAIlC,KAAJ,CAAU,4BAAV,CAAP;AACDY,IAAAA,UAAU,CAACC,GAAD,EAAM,KAAKC,KAAX,CAAV;AACA,GAJD,MAIO;AACNF,IAAAA,UAAU,CAACC,GAAD,EAAM,KAAKC,KAAX,EAAkB,CAAE,OAAF,CAAlB,CAAV;AACA;;AAED,OAAK4B,WAAL,CAAiBa,EAAE,GAAGrB,MAAH,GAAYiB,SAAS,CAACtC,GAAD,CAAxC,EAA+CA,GAA/C,EAAoD1C,MAApD,EAA4DC,MAA5D;AACA,CA1BD;AA4BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASqF,OAAT,CAAiBpF,GAAjB,EACA;AACC,MAAIA,GAAG,KAAKiD,SAAZ,EACC,MAAO,IAAItB,KAAJ,CAAU,6BAAV,CAAP;AAED,MAAI,CAACoB,KAAK,CAACoC,OAAN,CAAcnF,GAAd,CAAL,EACC,MAAO,IAAI2B,KAAJ,CAAU,wBAAV,CAAP;AAED,MAAI3B,GAAG,CAACe,MAAJ,IAAc,CAAlB,EACC,MAAO,IAAIY,KAAJ,CAAU,oCAAV,CAAP;AAED;;AACA,MAAI3B,GAAG,CAAC,CAAD,CAAH,IAAU,QAAd,EACC,MAAO,IAAI2B,KAAJ,CAAU,iCAAV,CAAP;AAED,SAAQ3B,GAAG,CAAC,CAAD,CAAH,GAASqF,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,CAAT,GAA2BtF,GAAG,CAAC,CAAD,CAAtC;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASuF,UAAT,CAAoBvF,GAApB,EACA;AACC,MAAIA,GAAG,KAAKiD,SAAZ,EACC,MAAO,IAAItB,KAAJ,CAAU,6BAAV,CAAP;AAED,MAAI,CAACoB,KAAK,CAACoC,OAAN,CAAcnF,GAAd,CAAL,EACC,MAAO,IAAI2B,KAAJ,CAAU,wBAAV,CAAP;AAED,MAAI3B,GAAG,CAACe,MAAJ,IAAc,CAAlB,EACC,MAAO,IAAIY,KAAJ,CAAU,oCAAV,CAAP;AAED,SAAQ0D,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkBtF,GAAG,CAAC,CAAD,CAArB,GAA2BA,GAAG,CAAC,CAAD,CAAtC;AACA;;AAED,SAASwF,QAAT,CAAkBC,IAAlB,EAAwBpC,IAAxB,EACA;AACC,MAAIqC,KAAK,GAAG,IAAItC,WAAJ,CAAgBC,IAAhB,CAAZ;AACAvF,EAAAA,OAAO,CAAC6H,YAAR,CAAqBF,IAArB,EAA2BC,KAA3B;AAEA,SAAQA,KAAR;AACA;AAED;AACA;AACA;AACA;;;AACAE,OAAO,CAACC,MAAR,GAAiBzC,WAAjB;AACAwC,OAAO,CAACR,OAAR,GAAkBA,OAAlB;AACAQ,OAAO,CAACL,UAAR,GAAqBA,UAArB;AAEAK,OAAO,CAACJ,QAAR,GAAmBA,QAAnB;AAEAI,OAAO,CAAC3F,MAAR,GAAiBjC,QAAQ,CAACiC,MAA1B;AACA2F,OAAO,CAACxF,OAAR,GAAkBpC,QAAQ,CAACoC,OAA3B;AACAwF,OAAO,CAACvF,OAAR,GAAkBrC,QAAQ,CAACqC,OAA3B;AACAuF,OAAO,CAACtF,OAAR,GAAkBtC,QAAQ,CAACsC,OAA3B;AACAsF,OAAO,CAAC3E,MAAR,GAAiBjD,QAAQ,CAACiD,MAA1B;AACA2E,OAAO,CAAC1E,OAAR,GAAkBlD,QAAQ,CAACkD,OAA3B;AACA0E,OAAO,CAACzE,OAAR,GAAkBnD,QAAQ,CAACmD,OAA3B;AACAyE,OAAO,CAACxE,OAAR,GAAkBpD,QAAQ,CAACoD,OAA3B;AAEAwE,OAAO,CAACrF,MAAR,GAAiBvC,QAAQ,CAACuC,MAA1B;AACAqF,OAAO,CAACpF,OAAR,GAAkBxC,QAAQ,CAACwC,OAA3B;AACAoF,OAAO,CAACnF,OAAR,GAAkBzC,QAAQ,CAACyC,OAA3B;AACAmF,OAAO,CAAClF,OAAR,GAAkB1C,QAAQ,CAAC0C,OAA3B;AACAkF,OAAO,CAACvE,MAAR,GAAiBrD,QAAQ,CAACqD,MAA1B;AACAuE,OAAO,CAACtE,OAAR,GAAkBtD,QAAQ,CAACsD,OAA3B;AACAsE,OAAO,CAACrE,OAAR,GAAkBvD,QAAQ,CAACuD,OAA3B;AACAqE,OAAO,CAACpE,OAAR,GAAkBxD,QAAQ,CAACwD,OAA3B;AAEAoE,OAAO,CAACjF,MAAR,GAAiB3C,QAAQ,CAAC2C,MAA1B;AACAiF,OAAO,CAAChF,OAAR,GAAkB5C,QAAQ,CAAC4C,OAA3B;AACAgF,OAAO,CAACnE,MAAR,GAAiBzD,QAAQ,CAACyD,MAA1B;AACAmE,OAAO,CAAClE,OAAR,GAAkB1D,QAAQ,CAAC0D,OAA3B","sourcesContent":["/*\n * rm - Feb 2011\n * ctype.js\n *\n * This module provides a simple abstraction towards reading and writing\n * different types of binary data. It is designed to use ctio.js and provide a\n * richer and more expressive API on top of it.\n *\n * By default we support the following as built in basic types:\n *\tint8_t\n *\tint16_t\n *\tint32_t\n *\tuint8_t\n *\tuint16_t\n *\tuint32_t\n *\tuint64_t\n *\tfloat\n *\tdouble\n *\tchar\n *\tchar[]\n *\n * Each type is returned as a Number, with the exception of char and char[]\n * which are returned as Node Buffers. A char is considered a uint8_t.\n *\n * Requests to read and write data are specified as an array of JSON objects.\n * This is also the same way that one declares structs. Even if just a single\n * value is requested, it must be done as a struct. The array order determines\n * the order that we try and read values. Each entry has the following format\n * with values marked with a * being optional.\n *\n * { key: { type: /type/, value*: /value/, offset*: /offset/ }\n *\n * If offset is defined, we lseek(offset, SEEK_SET) before reading the next\n * value. Value is defined when we're writing out data, otherwise it's ignored.\n *\n */\n\nvar mod_ctf = require('./ctf.js');\nvar mod_ctio = require('./ctio.js');\nvar mod_assert = require('assert');\n\n/*\n * This is the set of basic types that we support.\n *\n *\tread\t\tThe function to call to read in a value from a buffer\n *\n *\twrite\t\tThe function to call to write a value to a buffer\n *\n */\nvar deftypes = {\n    'uint8_t':  { read: ctReadUint8, write: ctWriteUint8 },\n    'uint16_t': { read: ctReadUint16, write: ctWriteUint16 },\n    'uint32_t': { read: ctReadUint32, write: ctWriteUint32 },\n    'uint64_t': { read: ctReadUint64, write: ctWriteUint64 },\n    'int8_t': { read: ctReadSint8, write: ctWriteSint8 },\n    'int16_t': { read: ctReadSint16, write: ctWriteSint16 },\n    'int32_t': { read: ctReadSint32, write: ctWriteSint32 },\n    'int64_t': { read: ctReadSint64, write: ctWriteSint64 },\n    'float': { read: ctReadFloat, write: ctWriteFloat },\n    'double': { read: ctReadDouble, write: ctWriteDouble },\n    'char': { read: ctReadChar, write: ctWriteChar },\n    'char[]': { read: ctReadCharArray, write: ctWriteCharArray }\n};\n\n/*\n * The following are wrappers around the CType IO low level API. They encode\n * knowledge about the size and return something in the expected format.\n */\nfunction ctReadUint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadUint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadUint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadUint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.ruint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadSint8(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint8(buffer, endian, offset);\n\treturn ({ value: val, size: 1 });\n}\n\nfunction ctReadSint16(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint16(buffer, endian, offset);\n\treturn ({ value: val, size: 2 });\n}\n\nfunction ctReadSint32(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint32(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadSint64(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rsint64(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\nfunction ctReadFloat(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rfloat(buffer, endian, offset);\n\treturn ({ value: val, size: 4 });\n}\n\nfunction ctReadDouble(endian, buffer, offset)\n{\n\tvar val = mod_ctio.rdouble(buffer, endian, offset);\n\treturn ({ value: val, size: 8 });\n}\n\n/*\n * Reads a single character into a node buffer\n */\nfunction ctReadChar(endian, buffer, offset)\n{\n\tvar res = new Buffer(1);\n\tres[0] = mod_ctio.ruint8(buffer, endian, offset);\n\treturn ({ value: res, size: 1 });\n}\n\nfunction ctReadCharArray(length, endian, buffer, offset)\n{\n\tvar ii;\n\tvar res = new Buffer(length);\n\n\tfor (ii = 0; ii < length; ii++)\n\t\tres[ii] = mod_ctio.ruint8(buffer, endian, offset + ii);\n\n\treturn ({ value: res, size: length });\n}\n\nfunction ctWriteUint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteUint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteUint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteUint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wuint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteSint8(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint8(value, endian, buffer, offset);\n\treturn (1);\n}\n\nfunction ctWriteSint16(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint16(value, endian, buffer, offset);\n\treturn (2);\n}\n\nfunction ctWriteSint32(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint32(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteSint64(value, endian, buffer, offset)\n{\n\tmod_ctio.wsint64(value, endian, buffer, offset);\n\treturn (8);\n}\n\nfunction ctWriteFloat(value, endian, buffer, offset)\n{\n\tmod_ctio.wfloat(value, endian, buffer, offset);\n\treturn (4);\n}\n\nfunction ctWriteDouble(value, endian, buffer, offset)\n{\n\tmod_ctio.wdouble(value, endian, buffer, offset);\n\treturn (8);\n}\n\n/*\n * Writes a single character into a node buffer\n */\nfunction ctWriteChar(value, endian, buffer, offset)\n{\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tmod_ctio.ruint8(value[0], endian, buffer, offset);\n\treturn (1);\n}\n\n/*\n * We're going to write 0s into the buffer if the string is shorter than the\n * length of the array.\n */\nfunction ctWriteCharArray(value, length, endian, buffer, offset)\n{\n\tvar ii;\n\n\tif (!(value instanceof Buffer))\n\t\tthrow (new Error('Input must be a buffer'));\n\n\tif (value.length > length)\n\t\tthrow (new Error('value length greater than array length'));\n\n\tfor (ii = 0; ii < value.length && ii < length; ii++)\n\t\tmod_ctio.wuint8(value[ii], endian, buffer, offset + ii);\n\n\tfor (; ii < length; ii++)\n\t\tmod_ctio.wuint8(0, endian, offset + ii);\n\n\n\treturn (length);\n}\n\n/*\n * Each parser has their own set of types. We want to make sure that they each\n * get their own copy as they may need to modify it.\n */\nfunction ctGetBasicTypes()\n{\n\tvar ret = {};\n\tvar key;\n\tfor (key in deftypes)\n\t\tret[key] = deftypes[key];\n\n\treturn (ret);\n}\n\n/*\n * Given a string in the form of type[length] we want to split this into an\n * object that extracts that information. We want to note that we could possibly\n * have nested arrays so this should only check the furthest one. It may also be\n * the case that we have no [] pieces, in which case we just return the current\n * type.\n */\nfunction ctParseType(str)\n{\n\tvar begInd, endInd;\n\tvar type, len;\n\tif (typeof (str) != 'string')\n\t\tthrow (new Error('type must be a Javascript string'));\n\n\tendInd = str.lastIndexOf(']');\n\tif (endInd == -1) {\n\t\tif (str.lastIndexOf('[') != -1)\n\t\t\tthrow (new Error('found invalid type with \\'[\\' but ' +\n\t\t\t    'no corresponding \\']\\''));\n\n\t\treturn ({ type: str });\n\t}\n\n\tbegInd = str.lastIndexOf('[');\n\tif (begInd == -1)\n\t\tthrow (new Error('found invalid type with \\']\\' but ' +\n\t\t    'no corresponding \\'[\\''));\n\n\tif (begInd >= endInd)\n\t\tthrow (new Error('malformed type, \\']\\' appears before \\'[\\''));\n\n\ttype = str.substring(0, begInd);\n\tlen = str.substring(begInd + 1, endInd);\n\n\treturn ({ type: type, len: len });\n}\n\n/*\n * Given a request validate that all of the fields for it are valid and make\n * sense. This includes verifying the following notions:\n *  - Each type requested is present in types\n *  - Only allow a name for a field to be specified once\n *  - If an array is specified, validate that the requested field exists and\n *    comes before it.\n *  - If fields is defined, check that each entry has the occurrence of field\n */\nfunction ctCheckReq(def, types, fields)\n{\n\tvar ii, jj;\n\tvar req, keys, key;\n\tvar found = {};\n\n\tif (!(def instanceof Array))\n\t\tthrow (new Error('definition is not an array'));\n\n\tif (def.length === 0)\n\t\tthrow (new Error('definition must have at least one element'));\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\treq = def[ii];\n\t\tif (!(req instanceof Object))\n\t\t\tthrow (new Error('definition must be an array of' +\n\t\t\t    'objects'));\n\n\t\tkeys = Object.keys(req);\n\t\tif (keys.length != 1)\n\t\t\tthrow (new Error('definition entry must only have ' +\n\t\t\t    'one key'));\n\n\t\tif (keys[0] in found)\n\t\t\tthrow (new Error('Specified name already ' +\n\t\t\t    'specified: ' + keys[0]));\n\n\t\tif (!('type' in req[keys[0]]))\n\t\t\tthrow (new Error('missing required type definition'));\n\n\t\tkey = ctParseType(req[keys[0]]['type']);\n\n\t\t/*\n\t\t * We may have nested arrays, we need to check the validity of\n\t\t * the types until the len field is undefined in key. However,\n\t\t * each time len is defined we need to verify it is either an\n\t\t * integer or corresponds to an already seen key.\n\t\t */\n\t\twhile (key['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(key['len'], 10))) {\n\t\t\t\tif (!(key['len'] in found))\n\t\t\t\t\tthrow (new Error('Given an array ' +\n\t\t\t\t\t    'length without a matching type'));\n\n\t\t\t}\n\n\t\t\tkey = ctParseType(key['type']);\n\t\t}\n\n\t\t/* Now we can validate if the type is valid */\n\t\tif (!(key['type'] in types))\n\t\t\tthrow (new Error('type not found or typdefed: ' +\n\t\t\t    key['type']));\n\n\t\t/* Check for any required fields */\n\t\tif (fields !== undefined) {\n\t\t\tfor (jj = 0; jj < fields.length; jj++) {\n\t\t\t\tif (!(fields[jj] in req[keys[0]]))\n\t\t\t\t\tthrow (new Error('Missing required ' +\n\t\t\t\t\t    'field: ' + fields[jj]));\n\t\t\t}\n\t\t}\n\n\t\tfound[keys[0]] = true;\n\t}\n}\n\n\n/*\n * Create a new instance of the parser. Each parser has its own store of\n * typedefs and endianness. Conf is an object with the following required\n * values:\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n * And the following optional values:\n *\n * \tchar-type\tValid options here are uint8 and int8. If uint8 is\n * \t\t\tspecified this changes the default behavior of a single\n * \t\t\tchar from being a buffer of a single character to being\n * \t\t\ta uint8_t. If int8, it becomes an int8_t instead.\n */\nfunction CTypeParser(conf)\n{\n\tif (!conf) throw (new Error('missing required argument'));\n\n\tif (!('endian' in conf))\n\t\tthrow (new Error('missing required endian value'));\n\n\tif (conf['endian'] != 'big' && conf['endian'] != 'little')\n\t\tthrow (new Error('Invalid endian type'));\n\n\tif ('char-type' in conf && (conf['char-type'] != 'uint8' &&\n\t    conf['char-type'] != 'int8'))\n\t\tthrow (new Error('invalid option for char-type: ' +\n\t\t    conf['char-type']));\n\n\tthis.endian = conf['endian'];\n\tthis.types = ctGetBasicTypes();\n\n\t/*\n\t * There may be a more graceful way to do this, but this will have to\n\t * serve.\n\t */\n\tif ('char-type' in conf && conf['char-type'] == 'uint8')\n\t\tthis.types['char'] = this.types['uint8_t'];\n\n\tif ('char-type' in conf && conf['char-type'] == 'int8')\n\t\tthis.types['char'] = this.types['int8_t'];\n}\n\n/*\n * Sets the current endian value for the Parser. If the value is not valid,\n * throws an Error.\n *\n *\tendian\t\tEither 'big' or 'little' do determine the endianness we\n *\t\t\twant to read from or write to.\n *\n */\nCTypeParser.prototype.setEndian = function (endian)\n{\n\tif (endian != 'big' && endian != 'little')\n\t\tthrow (new Error('invalid endian type, must be big or ' +\n\t\t    'little'));\n\n\tthis.endian = endian;\n};\n\n/*\n * Returns the current value of the endian value for the parser.\n */\nCTypeParser.prototype.getEndian = function ()\n{\n\treturn (this.endian);\n};\n\n/*\n * A user has requested to add a type, let us honor their request. Yet, if their\n * request doth spurn us, send them unto the Hells which Dante describes.\n *\n * \tname\t\tThe string for the type definition we're adding\n *\n *\tvalue\t\tEither a string that is a type/array name or an object\n *\t\t\tthat describes a struct.\n */\nCTypeParser.prototype.typedef = function (name, value)\n{\n\tvar type;\n\n\tif (name === undefined)\n\t\tthrow (new (Error('missing required typedef argument: name')));\n\n\tif (value === undefined)\n\t\tthrow (new (Error('missing required typedef argument: value')));\n\n\tif (typeof (name) != 'string')\n\t\tthrow (new (Error('the name of a type must be a string')));\n\n\ttype = ctParseType(name);\n\n\tif (type['len'] !== undefined)\n\t\tthrow (new Error('Cannot have an array in the typedef name'));\n\n\tif (name in this.types)\n\t\tthrow (new Error('typedef name already present: ' + name));\n\n\tif (typeof (value) != 'string' && !(value instanceof Array))\n\t\tthrow (new Error('typedef value must either be a string or ' +\n\t\t    'struct'));\n\n\tif (typeof (value) == 'string') {\n\t\ttype = ctParseType(value);\n\t\tif (type['len'] !== undefined) {\n\t\t\tif (isNaN(parseInt(type['len'], 10)))\n\t\t\t\tthrow (new (Error('typedef value must use ' +\n\t\t\t\t    'fixed size array when outside of a ' +\n\t\t\t\t    'struct')));\n\t\t}\n\n\t\tthis.types[name] = value;\n\t} else {\n\t\t/* We have a struct, validate it */\n\t\tctCheckReq(value, this.types);\n\t\tthis.types[name] = value;\n\t}\n};\n\n/*\n * Include all of the typedefs, but none of the built in types. This should be\n * treated as read-only.\n */\nCTypeParser.prototype.lstypes = function ()\n{\n\tvar key;\n\tvar ret = {};\n\n\tfor (key in this.types) {\n\t\tif (key in deftypes)\n\t\t\tcontinue;\n\t\tret[key] = this.types[key];\n\t}\n\n\treturn (ret);\n};\n\n/*\n * Given a type string that may have array types that aren't numbers, try and\n * fill them in from the values object. The object should be of the format where\n * indexing into it should return a number for that type.\n *\n *\tstr\t\tThe type string\n *\n *\tvalues\t\tAn object that can be used to fulfill type information\n */\nfunction ctResolveArray(str, values)\n{\n\tvar ret = '';\n\tvar type = ctParseType(str);\n\n\twhile (type['len'] !== undefined) {\n\t\tif (isNaN(parseInt(type['len'], 10))) {\n\t\t\tif (typeof (values[type['len']]) != 'number')\n\t\t\t\tthrow (new Error('cannot sawp in non-number ' +\n\t\t\t\t    'for array value'));\n\t\t\tret = '[' + values[type['len']] + ']' + ret;\n\t\t} else {\n\t\t\tret = '[' + type['len'] + ']' + ret;\n\t\t}\n\t\ttype = ctParseType(type['type']);\n\t}\n\n\tret = type['type'] + ret;\n\n\treturn (ret);\n}\n\n/*\n * [private] Either the typedef resolves to another type string or to a struct.\n * If it resolves to a struct, we just pass it off to read struct. If not, we\n * can just pass it off to read entry.\n */\nCTypeParser.prototype.resolveTypedef = function (type, dispatch, buffer,\n    offset, value)\n{\n\tvar pt;\n\n\tmod_assert.ok(type in this.types);\n\tif (typeof (this.types[type]) == 'string') {\n\t\tpt = ctParseType(this.types[type]);\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readEntry(pt, buffer, offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeEntry(value, pt, buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t} else {\n\t\tif (dispatch == 'read')\n\t\t\treturn (this.readStruct(this.types[type], buffer,\n\t\t\t    offset));\n\t\telse if (dispatch == 'write')\n\t\t\treturn (this.writeStruct(value, this.types[type],\n\t\t\t    buffer, offset));\n\t\telse\n\t\t\tthrow (new Error('invalid dispatch type to ' +\n\t\t\t    'resolveTypedef'));\n\t}\n\n};\n\n/*\n * [private] Try and read in the specific entry.\n */\nCTypeParser.prototype.readEntry = function (type, buffer, offset)\n{\n\tvar parse, len;\n\n\t/*\n\t * Because we want to special case char[]s this is unfortunately\n\t * a bit uglier than it really should be. We want to special\n\t * case char[]s so that we return a node buffer, thus they are a\n\t * first class type where as all other arrays just call into a\n\t * generic array routine which calls their data-specific routine\n\t * the specified number of times.\n\t *\n\t * The valid dispatch options we have are:\n\t *  - Array and char => char[] handler\n\t *  - Generic array handler\n\t *  - Generic typedef handler\n\t *  - Basic type handler\n\t */\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tparse = this.types['char[]']['read'](len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tparse = this.readArray(type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tparse = this.types[type['type']]['read'](this.endian,\n\t\t\t    buffer, offset);\n\t\telse\n\t\t\tparse = this.resolveTypedef(type['type'], 'read',\n\t\t\t    buffer, offset);\n\t}\n\n\treturn (parse);\n};\n\n/*\n * [private] Read an array of data\n */\nCTypeParser.prototype.readArray = function (type, length, buffer, offset)\n{\n\tvar ii, ent, pt;\n\tvar baseOffset = offset;\n\tvar ret = new Array(length);\n\tpt = ctParseType(type);\n\n\tfor (ii = 0; ii < length; ii++) {\n\t\tent = this.readEntry(pt, buffer, offset);\n\t\toffset += ent['size'];\n\t\tret[ii] = ent['value'];\n\t}\n\n\treturn ({ value: ret, size: offset - baseOffset });\n};\n\n/*\n * [private] Read a single struct in.\n */\nCTypeParser.prototype.readStruct = function (def, buffer, offset)\n{\n\tvar parse, ii, type, entry, key;\n\tvar baseOffset = offset;\n\tvar ret = {};\n\n\t/* Walk it and handle doing what's necessary */\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\t/* Resolve all array values */\n\t\ttype = ctParseType(ctResolveArray(entry['type'], ret));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\tparse = this.readEntry(type, buffer, offset);\n\n\t\toffset += parse['size'];\n\t\tret[key] = parse['value'];\n\t}\n\n\treturn ({ value: ret, size: (offset-baseOffset)});\n};\n\n/*\n * This is what we were born to do. We read the data from a buffer and return it\n * in an object whose keys match the values from the object.\n *\n *\tdef\t\tThe array definition of the data to read in\n *\n *\tbuffer\t\tThe buffer to read data from\n *\n *\toffset\t\tThe offset to start writing to\n *\n * Returns an object where each key corresponds to an entry in def and the value\n * is the read value.\n */\nCTypeParser.prototype.readData = function (def, buffer, offset)\n{\n\t/* Sanity check for arguments */\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\t/* Sanity check the object definition */\n\tctCheckReq(def, this.types);\n\n\treturn (this.readStruct(def, buffer, offset)['value']);\n};\n\n/*\n * [private] Write out an array of data\n */\nCTypeParser.prototype.writeArray = function (value, type, length, buffer,\n    offset)\n{\n\tvar ii, pt;\n\tvar baseOffset = offset;\n\tif (!(value instanceof Array))\n\t\tthrow (new Error('asked to write an array, but value is not ' +\n\t\t    'an array'));\n\n\tif (value.length != length)\n\t\tthrow (new Error('asked to write array of length ' + length +\n\t\t    ' but that does not match value length: ' + value.length));\n\n\tpt = ctParseType(type);\n\tfor (ii = 0; ii < length; ii++)\n\t\toffset += this.writeEntry(value[ii], pt, buffer, offset);\n\n\treturn (offset - baseOffset);\n};\n\n/*\n * [private] Write the specific entry\n */\nCTypeParser.prototype.writeEntry = function (value, type, buffer, offset)\n{\n\tvar len, ret;\n\n\tif (type['len'] !== undefined) {\n\t\tlen = parseInt(type['len'], 10);\n\t\tif (isNaN(len))\n\t\t\tthrow (new Error('somehow got a non-numeric length'));\n\n\t\tif (type['type'] == 'char')\n\t\t\tret = this.types['char[]']['write'](value, len,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.writeArray(value, type['type'],\n\t\t\t    len, buffer, offset);\n\t} else {\n\t\tif (type['type'] in deftypes)\n\t\t\tret = this.types[type['type']]['write'](value,\n\t\t\t    this.endian, buffer, offset);\n\t\telse\n\t\t\tret = this.resolveTypedef(type['type'], 'write',\n\t\t\t    buffer, offset, value);\n\t}\n\n\treturn (ret);\n};\n\n/*\n * [private] Write a single struct out.\n */\nCTypeParser.prototype.writeStruct = function (value, def, buffer, offset)\n{\n\tvar ii, entry, type, key;\n\tvar baseOffset = offset;\n\tvar vals = {};\n\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tentry = def[ii][key];\n\n\t\ttype = ctParseType(ctResolveArray(entry['type'], vals));\n\n\t\tif ('offset' in entry)\n\t\t\toffset = baseOffset + entry['offset'];\n\n\t\toffset += this.writeEntry(value[ii], type, buffer, offset);\n\t\t/* Now that we've written it out, we can use it for arrays */\n\t\tvals[key] = value[ii];\n\t}\n\n\treturn (offset);\n};\n\n/*\n * Unfortunately, we're stuck with the sins of an initial poor design. Because\n * of that, we are going to have to support the old way of writing data via\n * writeData. There we insert the values that you want to write into the\n * definition. A little baroque. Internally, we use the new model. So we need to\n * just get those values out of there. But to maintain the principle of least\n * surprise, we're not going to modify the input data.\n */\nfunction getValues(def)\n{\n\tvar ii, out, key;\n\tout = [];\n\tfor (ii = 0; ii < def.length; ii++) {\n\t\tkey = Object.keys(def[ii])[0];\n\t\tmod_assert.ok('value' in def[ii][key]);\n\t\tout.push(def[ii][key]['value']);\n\t}\n\n\treturn (out);\n}\n\n/*\n * This is the second half of what we were born to do, write out the data\n * itself. Historically this function required you to put your values in the\n * definition section. This was not the smartest thing to do and a bit of an\n * oversight to be honest. As such, this function now takes a values argument.\n * If values is non-null and non-undefined, it will be used to determine the\n * values. This means that the old method is still supported, but is no longer\n * acceptable.\n *\n *\tdef\t\tThe array definition of the data to write out with\n *\t\t\tvalues\n *\n *\tbuffer\t\tThe buffer to write to\n *\n *\toffset\t\tThe offset in the buffer to write to\n *\n *\tvalues\t\tAn array of values to write.\n */\nCTypeParser.prototype.writeData = function (def, buffer, offset, values)\n{\n\tvar hv;\n\n\tif (def === undefined)\n\t\tthrow (new Error('missing definition for what we should be' +\n\t\t    'parsing'));\n\n\tif (buffer === undefined)\n\t\tthrow (new Error('missing buffer for what we should be ' +\n\t\t    'parsing'));\n\n\tif (offset === undefined)\n\t\tthrow (new Error('missing offset for what we should be ' +\n\t\t    'parsing'));\n\n\thv = (values != null && values != undefined);\n\tif (hv) {\n\t\tif (!Array.isArray(values))\n\t\t\tthrow (new Error('missing values for writing'));\n\t\tctCheckReq(def, this.types);\n\t} else {\n\t\tctCheckReq(def, this.types, [ 'value' ]);\n\t}\n\n\tthis.writeStruct(hv ? values : getValues(def), def, buffer, offset);\n};\n\n/*\n * Functions to go to and from 64 bit numbers in a way that is compatible with\n * Javascript limitations. There are two sets. One where the user is okay with\n * an approximation and one where they are definitely not okay with an\n * approximation.\n */\n\n/*\n * Attempts to convert an array of two integers returned from rsint64 / ruint64\n * into an absolute 64 bit number. If however the value would exceed 2^52 this\n * will instead throw an error. The mantissa in a double is a 52 bit number and\n * rather than potentially give you a value that is an approximation this will\n * error. If you would rather an approximation, please see toApprox64.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toAbs64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\t/* We have 20 bits worth of precision in this range */\n\tif (val[0] >= 0x100000)\n\t\tthrow (new Error('value would become approximated'));\n\n\treturn (val[0] * Math.pow(2, 32) + val[1]);\n}\n\n/*\n * Will return the 64 bit value as returned in an array from rsint64 / ruint64\n * to a value as close as it can. Note that Javascript stores all numbers as a\n * double and the mantissa only has 52 bits. Thus this version may approximate\n * the value.\n *\n *\tval\t\tAn array of two 32-bit integers\n */\nfunction toApprox64(val)\n{\n\tif (val === undefined)\n\t\tthrow (new Error('missing required arg: value'));\n\n\tif (!Array.isArray(val))\n\t\tthrow (new Error('value must be an array'));\n\n\tif (val.length != 2)\n\t\tthrow (new Error('value must be an array of length 2'));\n\n\treturn (Math.pow(2, 32) * val[0] + val[1]);\n}\n\nfunction parseCTF(json, conf)\n{\n\tvar ctype = new CTypeParser(conf);\n\tmod_ctf.ctfParseJson(json, ctype);\n\n\treturn (ctype);\n}\n\n/*\n * Export the few things we actually want to. Currently this is just the CType\n * Parser and ctio.\n */\nexports.Parser = CTypeParser;\nexports.toAbs64 = toAbs64;\nexports.toApprox64 = toApprox64;\n\nexports.parseCTF = parseCTF;\n\nexports.ruint8 = mod_ctio.ruint8;\nexports.ruint16 = mod_ctio.ruint16;\nexports.ruint32 = mod_ctio.ruint32;\nexports.ruint64 = mod_ctio.ruint64;\nexports.wuint8 = mod_ctio.wuint8;\nexports.wuint16 = mod_ctio.wuint16;\nexports.wuint32 = mod_ctio.wuint32;\nexports.wuint64 = mod_ctio.wuint64;\n\nexports.rsint8 = mod_ctio.rsint8;\nexports.rsint16 = mod_ctio.rsint16;\nexports.rsint32 = mod_ctio.rsint32;\nexports.rsint64 = mod_ctio.rsint64;\nexports.wsint8 = mod_ctio.wsint8;\nexports.wsint16 = mod_ctio.wsint16;\nexports.wsint32 = mod_ctio.wsint32;\nexports.wsint64 = mod_ctio.wsint64;\n\nexports.rfloat = mod_ctio.rfloat;\nexports.rdouble = mod_ctio.rdouble;\nexports.wfloat = mod_ctio.wfloat;\nexports.wdouble = mod_ctio.wdouble;\n"]},"metadata":{},"sourceType":"script"}